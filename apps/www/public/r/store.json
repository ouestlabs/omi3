{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "store",
  "type": "registry:lib",
  "description": "Audio store",
  "dependencies": [
    "zustand"
  ],
  "registryDependencies": [
    "@audio/lib"
  ],
  "files": [
    {
      "path": "src/registry/default/lib/audio-store.ts",
      "content": "import { create } from \"zustand\";\nimport { persist, subscribeWithSelector } from \"zustand/middleware\";\nimport { $audio, isLive, type Track } from \"@/registry/default/lib/audio\";\n\ntype RepeatMode = \"none\" | \"one\" | \"all\";\ntype InsertMode = \"first\" | \"last\" | \"after\";\n\ntype AudioStore = {\n  // State\n  currentTrack: Track | null;\n  queue: Track[];\n  history: Track[];\n  isPlaying: boolean;\n  isLoading: boolean;\n  isBuffering: boolean;\n  volume: number;\n  isMuted: boolean;\n  repeatMode: RepeatMode;\n  shuffleEnabled: boolean;\n  currentTime: number;\n  duration: number;\n  progress: number;\n  bufferedTime: number;\n  insertMode: InsertMode;\n  isError: boolean;\n  errorMessage: string | null;\n  currentQueueIndex: number;\n\n  // Playback Actions\n  play: () => void;\n  pause: () => void;\n  togglePlay: () => void;\n  next: () => void;\n  previous: () => void;\n  seek: (time: number) => void;\n  setQueueAndPlay: (tracks: Track[], startIndex: number) => Promise<void>;\n  handleTrackEnd: () => void;\n\n  // Queue Actions\n  addToQueue: (track: Track, mode?: InsertMode) => void;\n  removeFromQueue: (trackId: string) => void;\n  clearQueue: () => void;\n  moveInQueue: (fromIndex: number, toIndex: number) => void;\n  setQueue: (tracks: Track[], startIndex?: number) => void;\n  getCurrentQueueIndex: () => number;\n  addTracksToEndOfQueue: (tracksToAdd: Track[]) => void;\n\n  // Control Actions\n  setVolume: (params: { volume: number }) => void;\n  toggleMute: () => void;\n  changeRepeatMode: () => void;\n  setInsertMode: (mode: InsertMode) => void;\n  shuffle: () => void;\n  unshuffle: () => void;\n  setRepeatMode: (mode: RepeatMode) => void;\n\n  // State Actions\n  setCurrentTrack: (track: Track | null) => Promise<void>;\n  setError: (message: string | null) => void;\n};\n\nfunction canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n}\n\ntype QueueNavigationParams = {\n  queue: Track[];\n  currentQueueIndex: number;\n  shuffleEnabled: boolean;\n  repeatMode: RepeatMode;\n};\n\ntype GetRandomShuffleIndexParams = {\n  queueLength: number;\n  currentIndex: number;\n};\n\n/**\n * Calculates a random index for shuffle mode\n */\nconst getRandomShuffleIndex = (params: GetRandomShuffleIndexParams): number => {\n  const { queueLength, currentIndex } = params;\n  if (queueLength === 1) {\n    return 0;\n  }\n  let randomIndex: number;\n  do {\n    randomIndex = Math.floor(Math.random() * queueLength);\n  } while (randomIndex === currentIndex);\n  return randomIndex;\n};\n\ntype CalculateQueueIndexParams = QueueNavigationParams & {\n  direction: 1 | -1;\n};\n\n/**\n * Calculates the next or previous index in the queue based on direction\n */\nconst calculateQueueIndex = (params: CalculateQueueIndexParams): number => {\n  const { queue, currentQueueIndex, shuffleEnabled, repeatMode, direction } =\n    params;\n\n  if (queue.length === 0) {\n    return -1;\n  }\n\n  if (shuffleEnabled) {\n    const singleTrackIndex = repeatMode === \"none\" ? -1 : 0;\n    return queue.length === 1\n      ? singleTrackIndex\n      : getRandomShuffleIndex({\n          queueLength: queue.length,\n          currentIndex: currentQueueIndex,\n        });\n  }\n\n  const newIndex = currentQueueIndex + direction;\n  const isAtEnd = newIndex >= queue.length;\n  const isAtStart = newIndex < 0;\n\n  if (isAtEnd) {\n    return repeatMode === \"all\" ? 0 : -1;\n  }\n\n  if (isAtStart) {\n    return repeatMode === \"all\" ? queue.length - 1 : -1;\n  }\n\n  return newIndex;\n};\n\n/**\n * Calculates the index of the next track\n */\nconst calculateNextIndex = (params: QueueNavigationParams): number =>\n  calculateQueueIndex({\n    ...params,\n    direction: 1,\n  });\n\n/**\n * Calculates the index of the previous track\n */\nconst calculatePreviousIndex = (params: QueueNavigationParams): number =>\n  calculateQueueIndex({\n    ...params,\n    direction: -1,\n  });\n\n/**\n * Default state after successful track loading\n */\nconst getSuccessState = (params: { isPlaying?: boolean } = {}) => ({\n  isLoading: false,\n  isError: false,\n  errorMessage: null,\n  isBuffering: false,\n  isPlaying: params.isPlaying ?? false,\n});\n\n/**\n * Default state after loading error\n */\nconst getErrorState = (params: { errorMessage: string }) => ({\n  isLoading: false,\n  isPlaying: false,\n  isError: true,\n  errorMessage: params.errorMessage,\n  isBuffering: false,\n});\n\ntype LoadAndPlayTrackParams = {\n  track: Track;\n  queueIndex: number;\n  set: (partial: Partial<AudioStore>) => void;\n  errorMessage: string;\n};\n\n/**\n * Loads and plays a track with error handling\n */\nconst loadAndPlayTrack = async (\n  params: LoadAndPlayTrackParams\n): Promise<void> => {\n  const { track, queueIndex, set, errorMessage } = params;\n  const isLiveStream = isLive(track);\n\n  set({\n    currentTrack: track,\n    currentQueueIndex: queueIndex,\n    isLoading: true,\n    isBuffering: true,\n  });\n\n  try {\n    await $audio.load({\n      url: track.url,\n      startTime: 0,\n      isLiveStream,\n    });\n    await $audio.play();\n    set(getSuccessState({ isPlaying: true }));\n  } catch (error) {\n    console.error(errorMessage, error);\n    set(getErrorState({ errorMessage }));\n    throw error;\n  }\n};\n\nconst useAudioStore = create<AudioStore>()(\n  persist(\n    subscribeWithSelector((set, get) => ({\n      // Initial State\n      currentTrack: null,\n      queue: [],\n      history: [],\n      isPlaying: false,\n      isLoading: false,\n      isBuffering: false,\n      volume: 1,\n      isMuted: false,\n      repeatMode: \"none\",\n      shuffleEnabled: false,\n      currentTime: 0,\n      duration: 0,\n      progress: 0,\n      bufferedTime: 0,\n      insertMode: \"last\",\n      isError: false,\n      errorMessage: null,\n      currentQueueIndex: -1,\n\n      // Playback Actions\n      async play() {\n        if (get().isLoading) {\n          return;\n        }\n        await $audio.play();\n      },\n\n      pause() {\n        $audio.pause();\n      },\n\n      togglePlay() {\n        if (get().isLoading) {\n          return;\n        }\n        if ($audio.isPaused()) {\n          get().play();\n        } else {\n          get().pause();\n        }\n      },\n\n      async next() {\n        const state = get();\n        const nextIndex = calculateNextIndex({\n          queue: state.queue,\n          currentQueueIndex: state.currentQueueIndex,\n          shuffleEnabled: state.shuffleEnabled,\n          repeatMode: state.repeatMode,\n        });\n\n        const nextTrack = state.queue[nextIndex];\n        if (nextIndex === -1 || !nextTrack) {\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        await loadAndPlayTrack({\n          track: nextTrack,\n          queueIndex: nextIndex,\n          set,\n          errorMessage: \"Error loading/playing next track\",\n        });\n      },\n\n      async previous() {\n        const state = get();\n        const currentTime = $audio.getCurrentTime();\n        const RESTART_THRESHOLD = 3;\n\n        // If track has more than 3 seconds and shuffle is not enabled, restart the track\n        if (currentTime > RESTART_THRESHOLD && !state.shuffleEnabled) {\n          set({ isLoading: true });\n          try {\n            $audio.setCurrentTime(0);\n            set({ currentTime: 0, progress: 0, isLoading: false });\n            return;\n          } catch (error) {\n            console.error(\"Error restarting current track:\", error);\n            set({ isLoading: false });\n            return;\n          }\n        }\n\n        const prevIndex = calculatePreviousIndex({\n          queue: state.queue,\n          currentQueueIndex: state.currentQueueIndex,\n          shuffleEnabled: state.shuffleEnabled,\n          repeatMode: state.repeatMode,\n        });\n\n        const prevTrack = state.queue[prevIndex];\n        if (prevIndex === -1 || !prevTrack) {\n          if (prevIndex !== -1) {\n            console.error(\n              \"Inconsistency: previous index is valid but track not found\"\n            );\n          }\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        await loadAndPlayTrack({\n          track: prevTrack,\n          queueIndex: prevIndex,\n          set,\n          errorMessage: \"Error loading/playing previous track\",\n        });\n      },\n\n      seek(time: number) {\n        $audio.setCurrentTime(time);\n        set({ currentTime: time });\n      },\n\n      async setQueueAndPlay(songs: Track[], startIndex: number) {\n        const targetTrack = songs[startIndex];\n        if (!targetTrack) {\n          console.error(\"[Playback] Invalid startIndex for setQueueAndPlay\");\n          get().clearQueue();\n          $audio.pause();\n          set({\n            isPlaying: false,\n            isLoading: false,\n            currentTrack: null,\n            currentQueueIndex: -1,\n          });\n          return;\n        }\n\n        get().setQueue(songs, startIndex);\n\n        const errorMessage = `Error playing ${targetTrack.title || \"track\"}`;\n        await loadAndPlayTrack({\n          track: targetTrack,\n          queueIndex: startIndex,\n          set,\n          errorMessage,\n        });\n      },\n\n      handleTrackEnd() {\n        get().next();\n      },\n\n      // Queue Actions\n      setQueue(tracks: Track[], startIndex = 0) {\n        const currentTrack = tracks[startIndex] ?? null;\n        set({\n          queue: tracks,\n          currentQueueIndex: currentTrack ? startIndex : -1,\n          currentTrack,\n        });\n      },\n\n      getCurrentQueueIndex() {\n        return get().currentQueueIndex;\n      },\n\n      addToQueue(track: Track, mode = \"last\") {\n        const state = get();\n        if (!state.currentTrack) {\n          set({\n            currentTrack: track,\n            currentQueueIndex: 0,\n            queue: [track],\n          });\n          return;\n        }\n\n        switch (mode) {\n          case \"first\":\n            set({\n              queue: [track, ...state.queue],\n              currentQueueIndex: state.currentQueueIndex + 1,\n            });\n            break;\n          case \"after\":\n            set({\n              queue: [\n                ...state.queue.slice(0, state.currentQueueIndex + 1),\n                track,\n                ...state.queue.slice(state.currentQueueIndex + 1),\n              ],\n            });\n            break;\n          default:\n            set({ queue: [...state.queue, track] });\n        }\n      },\n\n      removeFromQueue(trackId) {\n        const state = get();\n        const index = state.queue.findIndex((s) => s.id === trackId);\n        if (index === -1) {\n          return;\n        }\n\n        const newQueue = state.queue.filter((s) => s.id !== trackId);\n        set({\n          queue: newQueue,\n          currentQueueIndex:\n            index < state.currentQueueIndex\n              ? state.currentQueueIndex - 1\n              : state.currentQueueIndex,\n        });\n      },\n\n      clearQueue() {\n        set({ queue: [] });\n      },\n\n      moveInQueue(fromIndex, toIndex) {\n        const newQueue = [...get().queue];\n        const [movedItem] = newQueue.splice(fromIndex, 1);\n        if (!movedItem) {\n          return;\n        }\n\n        newQueue.splice(toIndex, 0, movedItem);\n        set({ queue: newQueue });\n      },\n\n      addTracksToEndOfQueue(tracksToAdd: Track[]) {\n        if (!tracksToAdd || tracksToAdd.length === 0) {\n          return;\n        }\n\n        const state = get();\n        const currentQueueIds = new Set(state.queue.map((s) => s.id));\n        const newTracks = tracksToAdd.filter(\n          (track) => !currentQueueIds.has(track.id)\n        );\n\n        if (newTracks.length > 0) {\n          set({ queue: [...state.queue, ...newTracks] });\n        }\n      },\n\n      // Control Actions\n      setVolume(params: { volume: number }) {\n        const { volume } = params;\n        $audio.setVolume({ volume });\n        set({ volume, isMuted: volume === 0 });\n      },\n\n      toggleMute() {\n        const newMuted = !get().isMuted;\n        $audio.setMuted(newMuted);\n        set({ isMuted: newMuted });\n      },\n\n      changeRepeatMode() {\n        const modes: RepeatMode[] = [\"none\", \"one\", \"all\"];\n        const currentIndex = modes.indexOf(get().repeatMode);\n        const newMode = modes[(currentIndex + 1) % modes.length];\n        set({ repeatMode: newMode });\n      },\n\n      setRepeatMode(mode) {\n        set({ repeatMode: mode });\n      },\n\n      setInsertMode(mode) {\n        set({ insertMode: mode });\n      },\n\n      shuffle() {\n        const state = get();\n        if (\n          !state.queue.length ||\n          state.queue.length < 2 ||\n          !state.currentTrack\n        ) {\n          return;\n        }\n\n        const remainingQueue = state.queue.filter(\n          (_, index) => index !== state.currentQueueIndex\n        );\n        const shuffledRemaining = remainingQueue.sort(\n          () => Math.random() - 0.5\n        );\n        const newQueue = [state.currentTrack, ...shuffledRemaining];\n\n        set({\n          queue: newQueue,\n          currentQueueIndex: 0,\n          shuffleEnabled: true,\n        });\n      },\n\n      unshuffle() {\n        set({ shuffleEnabled: false });\n      },\n\n      // State Actions\n      async setCurrentTrack(track: Track | null) {\n        const state = get();\n\n        if (!track) {\n          $audio.cleanup();\n          set({\n            currentTrack: null,\n            currentQueueIndex: -1,\n            isPlaying: false,\n            currentTime: 0,\n            duration: 0,\n            queue: [],\n            isLoading: false,\n            isError: false,\n            errorMessage: null,\n          });\n          return;\n        }\n\n        // Avoid reloading the same track\n        if (state.currentTrack?.id === track.id) {\n          return;\n        }\n\n        const errorMessage = `Error: ${track.title || \"Unknown track\"}`;\n\n        // Update queue with a single track\n        set({\n          currentTrack: track,\n          queue: [track],\n          currentQueueIndex: 0,\n          isLoading: true,\n          isPlaying: false,\n          currentTime: 0,\n          duration: 0,\n          isError: false,\n          errorMessage: null,\n        });\n\n        await loadAndPlayTrack({\n          track,\n          queueIndex: 0,\n          set,\n          errorMessage,\n        });\n      },\n      setError: (message) => {\n        set({\n          isError: !!message,\n          errorMessage: message,\n          isLoading: false,\n          isPlaying: false,\n        });\n      },\n    })),\n    {\n      name: \"audio:ui:store\",\n      partialize: (state) => ({\n        currentTrack: state.currentTrack,\n        queue: state.queue,\n        history: state.history,\n        volume: state.volume,\n        isMuted: state.isMuted,\n        repeatMode: state.repeatMode,\n        shuffleEnabled: state.shuffleEnabled,\n        currentTime: state.currentTime,\n        insertMode: state.insertMode,\n        currentQueueIndex: state.currentQueueIndex,\n      }),\n    }\n  )\n);\n\nexport {\n  calculateNextIndex,\n  calculatePreviousIndex,\n  canUseDOM,\n  useAudioStore,\n  type AudioStore,\n  type RepeatMode,\n  type InsertMode,\n};\n",
      "type": "registry:lib",
      "target": "lib/audio-store.ts"
    }
  ],
  "categories": [
    "lib",
    "audio",
    "store"
  ]
}