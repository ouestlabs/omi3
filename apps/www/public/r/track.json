{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "track",
  "type": "registry:ui",
  "dependencies": [
    "lucide-react"
  ],
  "registryDependencies": [
    "@audio/empty",
    "@audio/sortable-list",
    "@shadcn/avatar",
    "@shadcn/button",
    "@shadcn/item",
    "@shadcn/scroll-area"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/audio/track.tsx",
      "content": "\"use client\";\n\nimport {\n  ListMusicIcon,\n  MusicIcon,\n  PauseIcon,\n  PlayIcon,\n  RadioIcon,\n  XIcon,\n} from \"lucide-react\";\nimport React from \"react\";\nimport {\n  formatDuration,\n  isLive,\n  type Track,\n} from \"@/registry/default/lib/audio\";\nimport { useAudioStore } from \"@/registry/default/lib/audio-store\";\nimport { cn } from \"@/registry/default/lib/utils\";\nimport {\n  Avatar,\n  AvatarFallback,\n  AvatarImage,\n} from \"@/registry/default/ui/avatar\";\nimport { Badge } from \"@/registry/default/ui/badge\";\nimport { Button } from \"@/registry/default/ui/button\";\nimport {\n  Empty,\n  EmptyDescription,\n  EmptyHeader,\n  EmptyMedia,\n  EmptyTitle,\n} from \"@/registry/default/ui/empty\";\nimport {\n  Item,\n  ItemActions,\n  ItemContent,\n  ItemDescription,\n  ItemMedia,\n  ItemTitle,\n} from \"@/registry/default/ui/item\";\nimport { ScrollArea } from \"@/registry/default/ui/scroll-area\";\nimport {\n  SortableDragHandle,\n  SortableItem,\n  SortableList,\n} from \"@/registry/default/ui/sortable-list\";\n\ntype AudioTrackProps = {\n  trackId: string | number;\n  index?: number;\n  onClick?: () => void;\n  onRemove?: (trackId: string) => void;\n  showRemove?: boolean;\n  showPlayPause?: boolean;\n  showDragHandle?: boolean;\n  showCover?: boolean;\n  className?: string;\n};\n\n// Helper function to get play/pause button title\nconst getPlayPauseTitle = (isCurrent: boolean, isPlaying: boolean): string => {\n  if (!isCurrent) {\n    return \"Play this track\";\n  }\n  if (isPlaying) {\n    return \"Pause\";\n  }\n  return \"Play\";\n};\n\n// Helper function to render track media (cover, drag handle, or index)\nconst renderTrackMedia = (\n  showDragHandle: boolean,\n  showCover: boolean,\n  track: Track,\n  index?: number\n) => {\n  // For sortable items, show drag handle alongside cover (not replacing it)\n  if (showDragHandle && showCover) {\n    const coverImage = track.artwork || track.images?.[0];\n    return (\n      <div className=\"flex items-center gap-2\">\n        <SortableDragHandle />\n        {coverImage ? (\n          <Avatar className=\"rounded-sm\">\n            <AvatarImage\n              alt={track.title}\n              className=\"object-cover\"\n              src={coverImage}\n            />\n            <AvatarFallback className=\"rounded-sm\">\n              <MusicIcon className=\"size-4 text-muted-foreground\" />\n            </AvatarFallback>\n          </Avatar>\n        ) : (\n          <div className=\"flex size-10 items-center justify-center rounded-sm bg-muted\">\n            <MusicIcon className=\"size-4 text-muted-foreground\" />\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // For non-sortable: just show drag handle\n  if (showDragHandle) {\n    return <SortableDragHandle />;\n  }\n\n  if (showCover) {\n    const coverImage = track.artwork || track.images?.[0];\n    if (coverImage) {\n      return (\n        <Avatar className=\"rounded-sm\">\n          <AvatarImage\n            alt={track.title}\n            className=\"object-cover\"\n            src={coverImage}\n          />\n          <AvatarFallback className=\"rounded-sm\">\n            <MusicIcon className=\"size-4 text-muted-foreground\" />\n          </AvatarFallback>\n        </Avatar>\n      );\n    }\n    return (\n      <div className=\"flex size-10 items-center justify-center rounded-sm bg-muted\">\n        <MusicIcon className=\"size-4 text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  const displayIndex = index !== undefined ? index + 1 : \"\";\n  return (\n    <span className=\"text-muted-foreground/60 text-xs\">{displayIndex}</span>\n  );\n};\n\nconst AudioTrack = ({\n  trackId,\n  index,\n  onClick,\n  onRemove,\n  showRemove = false,\n  showPlayPause = true,\n  showDragHandle = false,\n  showCover = true,\n  className,\n}: AudioTrackProps) => {\n  const queue = useAudioStore((state) => state.queue);\n  const currentTrack = useAudioStore((state) => state.currentTrack);\n  const isPlaying = useAudioStore((state) => state.isPlaying);\n  const duration = useAudioStore((state) => state.duration);\n  const togglePlay = useAudioStore((state) => state.togglePlay);\n  const setQueueAndPlay = useAudioStore((state) => state.setQueueAndPlay);\n\n  const track = React.useMemo(\n    () => queue.find((t) => String(t.id) === String(trackId)),\n    [queue, trackId]\n  );\n\n  if (!track) {\n    return null;\n  }\n\n  const isCurrent = currentTrack?.id === track.id;\n  const actualIsPlaying = isPlaying && isCurrent;\n  const isLiveTrack = isLive(track);\n\n  const trackDuration = isCurrent && duration > 0 ? duration : track.duration;\n\n  const handleRemove = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (track.id && onRemove) {\n      onRemove(String(track.id));\n    }\n  };\n\n  const handlePlayPause = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    e.preventDefault();\n\n    if (isCurrent) {\n      togglePlay();\n    } else {\n      const trackIndex = queue.findIndex((t) => t.id === track.id);\n      if (trackIndex >= 0) {\n        setQueueAndPlay(queue, trackIndex);\n      }\n    }\n  };\n\n  const itemVariant = isCurrent ? \"muted\" : \"default\";\n\n  const content = (\n    <Item\n      className={cn(\n        \"w-full cursor-pointer transition-all hover:bg-secondary/50\",\n        className\n      )}\n      onClick={(e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        onClick?.();\n      }}\n      size=\"sm\"\n      variant={itemVariant}\n    >\n      <ItemMedia>\n        {renderTrackMedia(showDragHandle, showCover, track, index)}\n      </ItemMedia>\n      <ItemContent className=\"min-w-0 flex-1 gap-0 overflow-hidden\">\n        <div className=\"flex items-center gap-1.5\">\n          <ItemTitle className=\"truncate font-medium text-sm leading-snug\">\n            {track.title}\n          </ItemTitle>\n          {isLiveTrack && (\n            <Badge className=\"bg-red-500/10 px-1 py-0.5 font-medium text-[10px] text-red-600 uppercase leading-none dark:bg-red-500/20 dark:text-red-400\">\n              <RadioIcon className=\"size-2.5\" />\n              Live\n            </Badge>\n          )}\n        </div>\n        <ItemDescription>{track.artist}</ItemDescription>\n      </ItemContent>\n      {!isLiveTrack && trackDuration !== undefined && (\n        <ItemContent className=\"flex-none text-center\">\n          <ItemDescription>{formatDuration(trackDuration)}</ItemDescription>\n        </ItemContent>\n      )}\n      <ItemActions>\n        {showRemove && !isCurrent && onRemove && (\n          <Button\n            onClick={handleRemove}\n            size=\"icon-sm\"\n            title=\"Remove\"\n            variant=\"ghost\"\n          >\n            <XIcon />\n          </Button>\n        )}\n        {showPlayPause && (\n          <Button\n            onClick={handlePlayPause}\n            size=\"icon-sm\"\n            title={getPlayPauseTitle(isCurrent, actualIsPlaying)}\n            variant=\"ghost\"\n          >\n            {actualIsPlaying ? (\n              <PauseIcon className=\"size-4 fill-current\" />\n            ) : (\n              <PlayIcon className=\"size-4 fill-current\" />\n            )}\n          </Button>\n        )}\n      </ItemActions>\n    </Item>\n  );\n\n  return content;\n};\n\nAudioTrack.displayName = \"AudioTrack\";\n\ntype AudioTrackListProps = {\n  onTrackSelect?: (index: number) => void;\n  onTrackRemove?: (trackId: string) => void;\n  sortable?: boolean;\n  showCover?: boolean;\n  variant?: \"default\" | \"grid\";\n  emptyLabel?: string;\n  emptyDescription?: string;\n  filterQuery?: string;\n  filterFn?: (track: Track) => boolean;\n  className?: string;\n};\n\n// Helper function to determine layout classes based on variant\nconst getLayoutClasses = (variant: \"default\" | \"grid\") => {\n  if (variant === \"grid\") {\n    return \"grid grid-cols-1 sm:grid-cols-2 gap-2\";\n  }\n  return \"space-y-2\";\n};\n\nconst AudioTrackList = ({\n  onTrackSelect,\n  onTrackRemove,\n  sortable = false,\n  showCover = true,\n  variant = \"default\",\n  emptyLabel = \"No tracks found\",\n  emptyDescription = \"Try adding some tracks\",\n  filterQuery,\n  filterFn,\n  className,\n}: AudioTrackListProps) => {\n  const queue = useAudioStore((state) => state.queue);\n  const currentTrack = useAudioStore((state) => state.currentTrack);\n  const setQueueAndPlay = useAudioStore((state) => state.setQueueAndPlay);\n  const togglePlay = useAudioStore((state) => state.togglePlay);\n  const setQueue = useAudioStore((state) => state.setQueue);\n  const currentQueueIndex = useAudioStore((state) => state.currentQueueIndex);\n\n  const tracks = React.useMemo(() => {\n    let filtered = queue;\n\n    if (filterFn) {\n      filtered = filtered.filter(filterFn);\n    } else if (filterQuery?.trim()) {\n      const query = filterQuery.toLowerCase();\n      filtered = filtered.filter(\n        (track: Track) =>\n          track.title?.toLowerCase().includes(query) ||\n          track.artist?.toLowerCase().includes(query)\n      );\n    }\n\n    return filtered;\n  }, [queue, filterQuery, filterFn]);\n\n  const isFiltered = (filterQuery?.trim().length ?? 0) > 0 || !!filterFn;\n\n  const handleAutoReorder = React.useCallback(\n    (reorderedTracks: Track[]) => {\n      if (!isFiltered) {\n        const newIndex =\n          currentTrack?.id !== undefined\n            ? reorderedTracks.findIndex((t) => t.id === currentTrack.id)\n            : -1;\n\n        let finalIndex = 0;\n        if (newIndex >= 0) {\n          finalIndex = newIndex;\n        } else if (\n          currentQueueIndex >= 0 &&\n          currentQueueIndex < reorderedTracks.length\n        ) {\n          finalIndex = currentQueueIndex;\n        }\n\n        setQueue(reorderedTracks, finalIndex);\n      }\n    },\n    [isFiltered, currentTrack?.id, currentQueueIndex, setQueue]\n  );\n\n  if (tracks.length === 0) {\n    return (\n      <Empty className={cn(\"mx-auto size-full border bg-muted/30\", className)}>\n        <EmptyHeader>\n          <EmptyMedia variant=\"icon\">\n            <ListMusicIcon />\n          </EmptyMedia>\n          <EmptyTitle>{emptyLabel}</EmptyTitle>\n          <EmptyDescription className=\"text-xs/relaxed\">\n            {emptyDescription}\n          </EmptyDescription>\n        </EmptyHeader>\n      </Empty>\n    );\n  }\n\n  const renderTrack = (track: Track, index: number, isOverlay = false) => {\n    const handleTrackClick = () => {\n      const queueIndex = queue.findIndex((t) => t.id === track.id);\n      if (queueIndex >= 0) {\n        if (currentTrack?.id === track.id) {\n          togglePlay();\n        } else {\n          setQueueAndPlay(queue, queueIndex);\n        }\n        onTrackSelect?.(queueIndex);\n      } else {\n        onTrackSelect?.(index);\n      }\n    };\n\n    if (!track.id) {\n      return null;\n    }\n\n    const showDragHandle = sortable && !isOverlay;\n\n    return (\n      <AudioTrack\n        index={index}\n        key={track.id}\n        onClick={handleTrackClick}\n        onRemove={onTrackRemove}\n        showCover={showCover}\n        showDragHandle={showDragHandle}\n        showRemove={!!onTrackRemove}\n        trackId={track.id}\n      />\n    );\n  };\n\n  const content = sortable ? (\n    <SortableList\n      className={\n        variant === \"grid\" ? \"grid grid-cols-1 gap-2 sm:grid-cols-2\" : \"gap-1\"\n      }\n      items={tracks\n        .filter((t) => t.id !== undefined)\n        .map((t) => ({ id: String(t.id) }))}\n      onChange={(reorderedTracks) => {\n        const reorderedTrackIds = reorderedTracks.map((t) => t.id);\n        const reorderedFullTracks = reorderedTrackIds\n          .map((id) => tracks.find((t) => String(t.id) === id))\n          .filter((t): t is Track => t !== undefined);\n        handleAutoReorder(reorderedFullTracks);\n      }}\n      renderItem={(item, index, isOverlay = false) => {\n        const track = tracks.find((t) => String(t.id) === item.id);\n        if (!track?.id) {\n          return null;\n        }\n        const originalIndex = tracks.findIndex((t) => t.id === track.id);\n        const trackIndex = originalIndex >= 0 ? originalIndex : index;\n\n        const trackContent = renderTrack(track, trackIndex, isOverlay);\n\n        return (\n          <SortableItem id={String(track.id)} key={track.id}>\n            {trackContent}\n          </SortableItem>\n        );\n      }}\n    />\n  ) : (\n    <div className={getLayoutClasses(variant)}>\n      {tracks.map((track, index) => renderTrack(track, index))}\n    </div>\n  );\n\n  return (\n    <ScrollArea\n      className={cn(\n        \"min-h-80 w-full scroll-pt-2 scroll-pb-1.5 pt-1\",\n        className\n      )}\n    >\n      {content}\n    </ScrollArea>\n  );\n};\n\nexport { AudioTrack, AudioTrackList };\n",
      "type": "registry:ui"
    }
  ]
}