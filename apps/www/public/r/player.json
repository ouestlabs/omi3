{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "player",
  "type": "registry:component",
  "dependencies": [
    "zustand",
    "lucide-react"
  ],
  "registryDependencies": [
    "@audio/store",
    "@audio/lib",
    "@audio/provider",
    "@audio/slider",
    "@shadcn/empty",
    "@shadcn/button",
    "@shadcn/dialog",
    "@shadcn/dropdown-menu",
    "@shadcn/input",
    "@shadcn/item",
    "@shadcn/scroll-area",
    "@shadcn/toggle",
    "@shadcn/tooltip"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/audio/player.tsx",
      "content": "\"use client\";\n\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport {\n  FastForwardIcon,\n  Loader2Icon,\n  PauseIcon,\n  PlayIcon,\n  RadioIcon,\n  RewindIcon,\n  SkipBackIcon,\n  SkipForwardIcon,\n  Volume1Icon,\n  Volume2Icon,\n  VolumeIcon,\n  VolumeXIcon,\n} from \"lucide-react\";\nimport React from \"react\";\nimport { formatDuration, isLive } from \"@/registry/default/lib/audio\";\nimport { useAudioStore } from \"@/registry/default/lib/audio-store\";\nimport { cn } from \"@/registry/default/lib/utils\";\nimport { Button, type buttonVariants } from \"@/registry/default/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuTrigger,\n} from \"@/registry/default/ui/dropdown-menu\";\nimport { Slider } from \"@/registry/default/ui/slider\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/registry/default/ui/tooltip\";\n\ninterface AudioPlayerButtonProps extends React.ComponentProps<typeof Button> {\n  tooltip?: boolean;\n  tooltipLabel?: string;\n}\n\nfunction AudioPlayerButton({\n  tooltip = false,\n  tooltipLabel,\n  ...props\n}: AudioPlayerButtonProps) {\n  const button = <Button {...props} />;\n\n  if (tooltip && tooltipLabel) {\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent sideOffset={4}>{tooltipLabel}</TooltipContent>\n      </Tooltip>\n    );\n  }\n\n  return button;\n}\n\nfunction AudioPlayer({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      className={cn(\n        \"w-full rounded-(--radius) border bg-card p-1.5\",\n        className\n      )}\n      data-slot=\"audio-player\"\n      role=\"presentation\"\n      {...props}\n    >\n      {children}\n    </div>\n  );\n}\n\nconst audioControlBarVariants = cva(\n  \"group/audio-control-bar flex w-full min-w-0 items-center gap-1.5\",\n  {\n    variants: {\n      variant: {\n        compact: \"flex-row\",\n        stacked: \"flex-col\",\n      },\n    },\n    defaultVariants: {\n      variant: \"compact\",\n    },\n  }\n);\n\n/**\n * Props for the AudioPlayerControlBar component.\n */\nexport type AudioPlayerControlBarProps = React.ComponentProps<\"div\"> &\n  VariantProps<typeof audioControlBarVariants>;\n\nconst AudioPlayerControlBar = ({\n  className,\n  variant,\n  ...props\n}: AudioPlayerControlBarProps) => (\n  <div\n    className={cn(audioControlBarVariants({ variant }), className)}\n    data-slot=\"audio-control-bar\"\n    data-variant={variant}\n    {...props}\n  />\n);\n\n/**\n * Props for the AudioPlayerControlGroup component.\n */\nexport type AudioPlayerControlGroupProps = React.ComponentProps<\"div\">;\n\nconst AudioPlayerControlGroup = ({\n  className,\n  ...props\n}: AudioPlayerControlGroupProps) => (\n  <div\n    className={cn(\"flex w-full items-center gap-1.5\", className)}\n    data-slot=\"audio-control-group\"\n    {...props}\n  />\n);\n\n/**\n * Props for the AudioPlayerTimeDisplay component.\n */\nexport type AudioPlayerTimeDisplayProps = React.ComponentProps<\"time\"> & {\n  remaining?: boolean;\n};\n\nconst AudioPlayerTimeDisplay = ({\n  className,\n  remaining,\n  ...props\n}: AudioPlayerTimeDisplayProps) => {\n  const { currentTime, duration, currentTrack } = useAudioStore();\n  const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n  const formattedCurrentTime = React.useMemo(\n    () => formatDuration(currentTime),\n    [currentTime]\n  );\n\n  const formattedRemainingTime = React.useMemo(\n    () => formatDuration(duration - currentTime),\n    [duration, currentTime]\n  );\n\n  const timeValue = React.useMemo(() => {\n    if (isLiveStream && remaining) {\n      return \"LIVE\";\n    }\n\n    if (isLiveStream && !remaining) {\n      return formattedCurrentTime;\n    }\n\n    return remaining ? formattedRemainingTime : formattedCurrentTime;\n  }, [isLiveStream, remaining, formattedCurrentTime, formattedRemainingTime]);\n\n  const showLiveIcon = isLiveStream && remaining;\n\n  return (\n    <time\n      className={cn(\n        \"min-w-12 shrink-0 px-1.5 text-left font-mono text-sm tabular-nums\",\n        remaining && \"text-right\",\n        showLiveIcon && \"flex items-center gap-1 text-red-500 text-xs\",\n        className\n      )}\n      data-live={isLiveStream ? \"true\" : undefined}\n      data-remaining={remaining ? \"true\" : undefined}\n      data-slot=\"audio-time-display\"\n      {...props}\n    >\n      {showLiveIcon && <RadioIcon className=\"size-3 animate-pulse\" />}\n      {timeValue}\n    </time>\n  );\n};\n\nconst AudioPlayerSeekBar = ({\n  className,\n  ...props\n}: Omit<\n  React.ComponentProps<typeof Slider>,\n  \"value\" | \"onValueChange\" | \"min\" | \"max\" | \"bufferValue\"\n>) => {\n  const { currentTime, duration, seek, bufferedTime, currentTrack } =\n    useAudioStore();\n  const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n  const progress = React.useMemo(() => {\n    if (isLiveStream) {\n      return 100;\n    }\n    if (!duration) {\n      return 0;\n    }\n    return (currentTime / duration) * 100;\n  }, [isLiveStream, currentTime, duration]);\n\n  const bufferedProgress = React.useMemo(() => {\n    if (isLiveStream) {\n      return 100;\n    }\n    if (!duration) {\n      return 0;\n    }\n    return (bufferedTime / duration) * 100;\n  }, [isLiveStream, bufferedTime, duration]);\n\n  const handleSeek = (e: React.MouseEvent | React.TouchEvent) => {\n    if (isLiveStream || !duration) {\n      return;\n    }\n\n    const target = e.currentTarget;\n    let clientX: number;\n\n    if (\"touches\" in e) {\n      clientX = e.touches[0]?.clientX ?? 0;\n    } else {\n      clientX = e.clientX;\n    }\n\n    const rect = target.getBoundingClientRect();\n    const position = Math.max(\n      0,\n      Math.min(1, (clientX - rect.left) / rect.width)\n    );\n    seek(position * duration);\n  };\n\n  const handleTouchStart = (e: React.TouchEvent) => {\n    if (!isLiveStream) {\n      handleSeek(e);\n    }\n  };\n\n  const handleTouchMove = (e: React.TouchEvent) => {\n    if (!isLiveStream) {\n      e.preventDefault();\n      handleSeek(e);\n    }\n  };\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    if (!isLiveStream && e.buttons === 1) {\n      handleSeek(e);\n    }\n  };\n\n  return (\n    <Slider\n      bufferValue={bufferedProgress}\n      className={cn(\"min-w-20 flex-1\", className)}\n      disabled={isLiveStream}\n      max={100}\n      min={0}\n      onMouseMove={handleMouseMove}\n      onTouchMove={handleTouchMove}\n      onTouchStart={handleTouchStart}\n      onValueChange={(value) => {\n        if (!isLiveStream && value?.[0] !== undefined && duration > 0) {\n          const newTime = (value[0] / 100) * duration;\n          seek(newTime);\n        }\n      }}\n      value={[progress]}\n      {...props}\n    />\n  );\n};\n\nconst AudioPlayerVolume = ({\n  className,\n  size = \"icon\",\n  variant = \"outline\",\n  ...props\n}: Omit<\n  React.ComponentProps<typeof Slider>,\n  \"value\" | \"onValueChange\" | \"min\" | \"max\"\n> & {\n  size?: VariantProps<typeof buttonVariants>[\"size\"];\n  variant?: VariantProps<typeof buttonVariants>[\"variant\"];\n}) => {\n  const volume = useAudioStore((state) => state.volume);\n  const isMuted = useAudioStore((state) => state.isMuted);\n  const setVolume = useAudioStore((state) => state.setVolume);\n  const toggleMute = useAudioStore((state) => state.toggleMute);\n\n  const volumePercent = Math.round(volume * 100);\n\n  const getVolumeIcon = () => {\n    if (isMuted || volume === 0) {\n      return VolumeXIcon;\n    }\n    if (volumePercent < 33) {\n      return VolumeIcon;\n    }\n    if (volumePercent < 66) {\n      return Volume1Icon;\n    }\n    return Volume2Icon;\n  };\n\n  const Icon = getVolumeIcon();\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <AudioPlayerButton\n          className={cn(\"hidden md:flex\", className)}\n          data-slot=\"audio-volume-button\"\n          size={size}\n          tooltip\n          tooltipLabel={\n            isMuted ? \"Muted\" : `Volume ${Math.round(volumePercent)}%`\n          }\n          variant={variant}\n        >\n          <Icon className={cn(isMuted && \"opacity-40\", \"text-primary\")} />\n        </AudioPlayerButton>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent\n        className={cn(\"flex w-48 flex-col gap-1.5 p-1.5\", className)}\n      >\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-sm\">Volume</span>\n          <span className=\"font-mono text-sm tabular-nums\">\n            {volumePercent}%\n          </span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <VolumeXIcon\n            aria-hidden=\"true\"\n            className={cn(\n              \"size-4 shrink-0 cursor-pointer\",\n              isMuted ? \"opacity-40\" : \"opacity-60\"\n            )}\n            onClick={toggleMute}\n            role=\"button\"\n          />\n          <Slider\n            className={cn(className)}\n            max={100}\n            min={0}\n            onValueChange={(value) => {\n              if (value?.[0] !== undefined) {\n                setVolume({ volume: value[0] / 100 });\n                if (value[0] === 0) {\n                  toggleMute();\n                } else if (isMuted) {\n                  toggleMute();\n                }\n              }\n            }}\n            value={[volumePercent]}\n            {...props}\n          />\n          <Volume2Icon\n            aria-hidden=\"true\"\n            className=\"size-4 shrink-0 opacity-60\"\n          />\n        </div>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n};\n\nconst AudioPlayerPlay = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const isPlaying = useAudioStore((state) => state.isPlaying);\n    const isLoading = useAudioStore((state) => state.isLoading);\n    const isBuffering = useAudioStore((state) => state.isBuffering);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n\n    const togglePlay = useAudioStore((state) => state.togglePlay);\n\n    const handleKeyPress = React.useCallback(\n      (event: KeyboardEvent) => {\n        if (event.code === \"Space\" && event.target === document.body) {\n          event.preventDefault();\n          togglePlay();\n        }\n      },\n      [togglePlay]\n    );\n\n    React.useEffect(() => {\n      document.addEventListener(\"keydown\", handleKeyPress);\n      return () => document.removeEventListener(\"keydown\", handleKeyPress);\n    }, [handleKeyPress]);\n\n    const showSpinner = isLoading || isBuffering;\n\n    const handleClick = React.useCallback(\n      (e: React.MouseEvent<HTMLButtonElement>) => {\n        onClick?.(e);\n        togglePlay();\n      },\n      [onClick, togglePlay]\n    );\n\n    return (\n      <AudioPlayerButton\n        aria-label={isPlaying ? \"Pause\" : \"Play\"}\n        className={cn(className)}\n        data-slot=\"audio-play-button\"\n        disabled={showSpinner || !currentTrack}\n        onClick={handleClick}\n        size={size}\n        tooltip\n        tooltipLabel={isPlaying ? \"Pause\" : \"Play\"}\n        variant={variant}\n        {...props}\n      >\n        {showSpinner && <Loader2Icon className=\"animate-spin\" />}\n        {!showSpinner && isPlaying && <PauseIcon fill=\"currentColor\" />}\n        {!(showSpinner || isPlaying) && <PlayIcon fill=\"currentColor\" />}\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerRewind = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const currentTime = useAudioStore((state) => state.currentTime);\n    const seek = useAudioStore((state) => state.seek);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n    const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n    const seekBackward = React.useCallback(\n      (seconds = 10) => {\n        const newTime = Math.max(currentTime - seconds, 0);\n        seek(newTime);\n      },\n      [currentTime, seek]\n    );\n\n    const disableSeekBackward = React.useMemo(\n      () => !currentTrack || currentTime <= 0 || isLiveStream,\n      [currentTrack, currentTime, isLiveStream]\n    );\n\n    return (\n      <AudioPlayerButton\n        className={cn(className)}\n        data-slot=\"audio-rewind-button\"\n        disabled={disableSeekBackward}\n        onClick={(e) => {\n          onClick?.(e);\n          if (!isLiveStream) {\n            seekBackward(10);\n          }\n        }}\n        size={size}\n        tooltip\n        tooltipLabel={\n          isLiveStream ? \"Not available for live streams\" : \"Skip backward\"\n        }\n        variant={variant}\n        {...props}\n      >\n        <RewindIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerFastForward = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const currentTime = useAudioStore((state) => state.currentTime);\n    const seek = useAudioStore((state) => state.seek);\n    const duration = useAudioStore((state) => state.duration);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n    const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n    const seekForward = React.useCallback(\n      (seconds = 10) => {\n        const newTime = Math.min(currentTime + seconds, duration);\n        seek(newTime);\n      },\n      [duration, seek, currentTime]\n    );\n\n    const disableSeekForward = React.useMemo(() => {\n      if (!currentTrack || isLiveStream) {\n        return true;\n      }\n      return duration > 0 && currentTime >= duration;\n    }, [currentTrack, currentTime, duration, isLiveStream]);\n\n    return (\n      <AudioPlayerButton\n        className={cn(className)}\n        data-slot=\"audio-fast-forward-button\"\n        disabled={disableSeekForward}\n        onClick={(e) => {\n          onClick?.(e);\n          if (!isLiveStream) {\n            seekForward(10);\n          }\n        }}\n        size={size}\n        tooltip\n        tooltipLabel={\n          isLiveStream ? \"Not available for live streams\" : \"Skip forward\"\n        }\n        variant={variant}\n        {...props}\n      >\n        <FastForwardIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerSkipForward = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const repeatMode = useAudioStore((state) => state.repeatMode);\n    const queueLength = useAudioStore((state) => state.queue.length);\n    const currentQueueIndex = useAudioStore((state) => state.currentQueueIndex);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n\n    const next = useAudioStore((state) => state.next);\n\n    const disableNext = React.useMemo(\n      () =>\n        !currentTrack ||\n        (currentQueueIndex === queueLength - 1 && repeatMode !== \"all\"),\n      [currentTrack, currentQueueIndex, queueLength, repeatMode]\n    );\n\n    return (\n      <AudioPlayerButton\n        aria-label=\"Next\"\n        className={cn(className)}\n        data-slot=\"audio-skip-forward-button\"\n        disabled={disableNext}\n        onClick={next}\n        size={size}\n        tooltip\n        tooltipLabel=\"Next\"\n        variant={variant}\n        {...props}\n      >\n        <SkipForwardIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerSkipBack = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const repeatMode = useAudioStore((state) => state.repeatMode);\n    const currentQueueIndex = useAudioStore((state) => state.currentQueueIndex);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n\n    const previous = useAudioStore((state) => state.previous);\n\n    const disablePrevious = React.useMemo(\n      () => !currentTrack || (currentQueueIndex === 0 && repeatMode !== \"all\"),\n      [currentTrack, currentQueueIndex, repeatMode]\n    );\n\n    return (\n      <AudioPlayerButton\n        className={cn(className)}\n        data-slot=\"audio-skip-back-button\"\n        disabled={disablePrevious}\n        onClick={previous}\n        size={size}\n        tooltip\n        tooltipLabel=\"Previous\"\n        variant={variant}\n        {...props}\n      >\n        <SkipBackIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nexport {\n  AudioPlayerButton,\n  AudioPlayerControlBar,\n  AudioPlayerControlGroup,\n  AudioPlayerFastForward,\n  AudioPlayerPlay,\n  AudioPlayerRewind,\n  AudioPlayerSeekBar,\n  AudioPlayerSkipBack,\n  AudioPlayerSkipForward,\n  AudioPlayerTimeDisplay,\n  AudioPlayerVolume,\n  AudioPlayer,\n};\n",
      "type": "registry:component",
      "target": "components/audio/player.tsx"
    },
    {
      "path": "src/registry/default/lib/audio.ts",
      "content": "export type Track = {\n  id?: string | number;\n  url: string;\n  title?: string;\n  artist?: string;\n  artwork?: string;\n  images?: string[];\n  duration?: number;\n  album?: string;\n  genre?: string;\n  live?: boolean;\n  [key: string]: unknown;\n};\n\ntype LoadParams = {\n  url: string;\n  startTime?: number;\n  isLiveStream?: boolean;\n};\n\ntype SetVolumeParams = {\n  volume: number;\n  fadeTime?: number;\n};\n\ntype FadeVolumeParams = {\n  audio: HTMLAudioElement;\n  targetVolume: number;\n  duration: number;\n};\n\nconst LIVE_STREAM_PATTERNS = [\n  /\\/live\\./i,\n  /\\/stream/i,\n  /\\/radio/i,\n  /\\.m3u8$/i,\n  /\\.pls$/i,\n  /\\.aac$/i,\n  /icecast|shoutcast/i,\n];\n\nclass AudioLib {\n  private audio: HTMLAudioElement | null = null;\n  private isInitialized = false;\n  private playPromise: Promise<void> | null = null;\n  private lastVolume = 1;\n  private fadeTimeout: NodeJS.Timeout | null = null;\n  private retryAttempts = 0;\n  private readonly maxRetries = 3;\n  private readonly eventTarget = new EventTarget();\n  private readonly LOAD_TIMEOUT_LIVE = 60_000;\n  private readonly LOAD_TIMEOUT_NORMAL = 30_000;\n  private readonly FADE_UPDATE_INTERVAL = 16;\n\n  /** Initialize the audio element and event listeners */\n  init(): void {\n    if (this.isInitialized || !this.isClient()) {\n      return;\n    }\n\n    this.isInitialized = true;\n\n    if (this.isClient()) {\n      this.audio = new Audio();\n      this.setupEventListeners();\n    }\n  }\n\n  private setupEventListeners(): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    if (!audio) {\n      return;\n    }\n\n    audio.addEventListener(\"error\", () => {\n      const errorDetails = {\n        code: audio.error?.code,\n        message: audio.error?.message,\n        event_type: `error_code_${audio.error?.code || \"unknown\"}`,\n        src: audio.src,\n        readyState: audio.readyState,\n        networkState: audio.networkState,\n        raw_error_object: audio.error,\n      };\n      console.error(\"### Detailed Audio Element Error ###\", errorDetails);\n\n      if (this.retryAttempts < this.maxRetries) {\n        this.retryAttempts += 1;\n\n        setTimeout(() => {\n          this.reloadAudio();\n        }, 1000);\n      }\n\n      this.eventTarget.dispatchEvent(new CustomEvent(\"audioError\"));\n    });\n\n    audio.addEventListener(\"playing\", () => {\n      this.retryAttempts = 0;\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingEnd\"));\n      this.eventTarget.dispatchEvent(new CustomEvent(\"playbackStarted\"));\n    });\n\n    audio.addEventListener(\"canplaythrough\", () => {\n      this.retryAttempts = 0;\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingEnd\"));\n    });\n\n    audio.addEventListener(\"waiting\", () => {\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingStart\"));\n    });\n\n    audio.addEventListener(\"progress\", () => {\n      const buffered = audio.buffered;\n      const currentTime = audio.currentTime;\n      let bufferedEnd = 0;\n\n      if (buffered.length === 0) {\n        return;\n      }\n\n      for (let i = buffered.length - 1; i >= 0; i--) {\n        if (buffered.start(i) <= currentTime) {\n          bufferedEnd = buffered.end(i);\n          break;\n        }\n      }\n\n      if (bufferedEnd === 0) {\n        bufferedEnd = buffered.end(0);\n      }\n\n      if (bufferedEnd > 0) {\n        this.eventTarget.dispatchEvent(\n          new CustomEvent(\"bufferUpdate\", {\n            detail: { bufferedTime: bufferedEnd },\n          })\n        );\n      }\n    });\n  }\n\n  cleanup(): void {\n    if (this.audio) {\n      this.audio.pause();\n      this.audio.src = \"\";\n      this.audio.load();\n    }\n\n    if (this.fadeTimeout) {\n      clearTimeout(this.fadeTimeout);\n      this.fadeTimeout = null;\n    }\n\n    this.playPromise = null;\n  }\n\n  getAudioElement(): HTMLAudioElement | null {\n    if (!this.isClient()) {\n      return null;\n    }\n    return this.audio;\n  }\n\n  private isClient(): boolean {\n    return typeof window !== \"undefined\" && !!window.document;\n  }\n\n  private ensureAudio(): HTMLAudioElement {\n    if (!this.isClient()) {\n      throw new Error(\"Audio module not available on server side\");\n    }\n    if (!this.audio) {\n      throw new Error(\"Audio module not initialized\");\n    }\n    return this.audio;\n  }\n\n  /**\n   * Executes a function only if on client side\n   */\n  private ifClient<T>(fn: () => T): T | undefined {\n    if (!this.isClient()) {\n      return;\n    }\n    return fn();\n  }\n\n  async load(params: LoadParams): Promise<void> {\n    const { url, startTime = 0, isLiveStream = false } = params;\n    const result = this.ifClient(() =>\n      this._load({ url, startTime, isLiveStream })\n    );\n    if (result) {\n      await result;\n    }\n  }\n\n  private async _load(params: {\n    url: string;\n    startTime: number;\n    isLiveStream: boolean;\n  }): Promise<void> {\n    const { url, startTime, isLiveStream } = params;\n    const audio = this.ensureAudio();\n    if (!audio) {\n      return;\n    }\n\n    try {\n      this.retryAttempts = 0;\n      if (audio.src === url) {\n        if (audio.currentTime !== startTime && !isLiveStream) {\n          audio.currentTime = startTime;\n        }\n        return;\n      }\n\n      audio.pause();\n      audio.src = \"\";\n\n      audio.src = url;\n      audio.preload = \"auto\";\n\n      const loadTimeout = isLiveStream\n        ? this.LOAD_TIMEOUT_LIVE\n        : this.LOAD_TIMEOUT_NORMAL;\n\n      await new Promise<void>((resolve, reject) => {\n        let timeoutId: NodeJS.Timeout | null = null;\n        let isResolved = false;\n\n        const cleanup = () => {\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n          }\n          audio.removeEventListener(\"loadedmetadata\", handleLoadSuccess);\n          audio.removeEventListener(\"canplay\", handleLoadSuccess);\n          audio.removeEventListener(\"canplaythrough\", handleLoadSuccess);\n          audio.removeEventListener(\"error\", handleErrorLoading);\n        };\n\n        const handleTimeout = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n\n          reject(\n            new Error(\n              `Audio load timeout (${loadTimeout / 1000}s). ReadyState: ${audio.readyState}, NetworkState: ${audio.networkState}, URL: ${audio.src}`\n            )\n          );\n        };\n\n        const handleLoadSuccess = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n\n          // Don't set currentTime for live streams\n          if (startTime > 0 && !isLiveStream) {\n            audio.currentTime = startTime;\n          }\n          resolve();\n        };\n\n        const handleErrorLoading = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n          console.error(\"Error during initial audio load:\", audio.error);\n          reject(\n            new Error(\n              `Audio load failed: ${audio.error?.message || \"Unknown error\"}`\n            )\n          );\n        };\n\n        timeoutId = setTimeout(handleTimeout, loadTimeout);\n\n        audio.addEventListener(\"loadedmetadata\", handleLoadSuccess);\n        audio.addEventListener(\"canplay\", handleLoadSuccess);\n        audio.addEventListener(\"canplaythrough\", handleLoadSuccess);\n        audio.addEventListener(\"error\", handleErrorLoading);\n        audio.load();\n      });\n    } catch (error) {\n      console.error(\"Audio load process error:\", error);\n      throw error;\n    }\n  }\n\n  async play(): Promise<void> {\n    const result = this.ifClient(() => this._play());\n    if (result) {\n      await result;\n    }\n  }\n\n  private async _play(): Promise<void> {\n    if (!this.audio) {\n      throw new Error(\"Audio module not initialized\");\n    }\n\n    try {\n      if (!this.audio.paused) {\n        return;\n      }\n      this.playPromise = this.audio.play();\n      await this.playPromise;\n      this.playPromise = null;\n    } catch (error) {\n      this.playPromise = null;\n      const errorDetails = {\n        error,\n        message: error instanceof Error ? error.message : \"Unknown error\",\n        stack: error instanceof Error ? error.stack : undefined,\n        url: this.audio.src,\n        readyState: this.audio.readyState,\n        networkState: this.audio.networkState,\n      };\n      console.error(\"Play error:\", errorDetails);\n      throw error;\n    }\n  }\n\n  private reloadAudio(): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    const currentTime = audio.currentTime;\n    const wasPlaying = !audio.paused;\n    const currentSrc = audio.src;\n\n    audio.pause();\n    audio.src = \"\";\n    audio.load();\n    audio.src = currentSrc;\n    audio.preload = \"auto\";\n    audio.load();\n\n    const setTimeAndPlay = () => {\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = currentTime;\n        if (wasPlaying) {\n          this.play().catch(console.error);\n        }\n        audio.removeEventListener(\"loadedmetadata\", setTimeAndPlay);\n      }\n    };\n\n    audio.addEventListener(\"loadedmetadata\", setTimeAndPlay);\n  }\n\n  pause(): void {\n    this.ifClient(() => {\n      const audio = this.ensureAudio();\n      audio.pause();\n    });\n  }\n\n  setVolume(params: SetVolumeParams): void {\n    const { volume, fadeTime = 0 } = params;\n    this.ifClient(() => {\n      const audio = this.ensureAudio();\n\n      if (this.fadeTimeout) {\n        clearTimeout(this.fadeTimeout);\n        this.fadeTimeout = null;\n      }\n\n      if (fadeTime <= 0) {\n        audio.volume = Math.max(0, Math.min(1, volume));\n        if (volume > 0) {\n          this.lastVolume = volume;\n        }\n        return;\n      }\n\n      this.fadeVolume({\n        audio,\n        targetVolume: volume,\n        duration: fadeTime,\n      });\n    });\n  }\n\n  private fadeVolume(params: FadeVolumeParams): void {\n    const { audio, targetVolume, duration } = params;\n    if (!this.isClient()) {\n      return;\n    }\n\n    const startVolume = audio.volume;\n    const endVolume = Math.max(0, Math.min(1, targetVolume));\n    const startTime = performance.now();\n\n    const updateVolume = () => {\n      const elapsed = performance.now() - startTime;\n      const progress = Math.min(1, elapsed / duration);\n      const currentVolume = startVolume + (endVolume - startVolume) * progress;\n\n      audio.volume = currentVolume;\n\n      if (progress < 1) {\n        this.fadeTimeout = setTimeout(updateVolume, this.FADE_UPDATE_INTERVAL);\n      } else {\n        if (endVolume > 0) {\n          this.lastVolume = endVolume;\n        }\n        this.fadeTimeout = null;\n      }\n    };\n\n    updateVolume();\n  }\n\n  getVolume(): number {\n    return (\n      this.ifClient(() => {\n        const audio = this.ensureAudio();\n        return audio.volume;\n      }) ?? 0\n    );\n  }\n\n  setMuted(muted: boolean): void {\n    this.ifClient(() => {\n      const audio = this.ensureAudio();\n      if (audio.muted === muted) {\n        return;\n      }\n\n      if (muted) {\n        if (audio.volume > 0) {\n          this.lastVolume = audio.volume;\n        }\n        this.fadeVolume({ audio, targetVolume: 0, duration: 200 });\n        audio.muted = true;\n      } else {\n        audio.muted = false;\n        this.fadeVolume({\n          audio,\n          targetVolume: this.lastVolume,\n          duration: 200,\n        });\n      }\n    });\n  }\n\n  getDuration(): number {\n    return (\n      this.ifClient(() => {\n        const audio = this.ensureAudio();\n        return audio.duration;\n      }) ?? 0\n    );\n  }\n\n  getCurrentTime(): number {\n    return (\n      this.ifClient(() => {\n        const audio = this.ensureAudio();\n        return audio.currentTime;\n      }) ?? 0\n    );\n  }\n\n  setCurrentTime(time: number): void {\n    this.ifClient(() => {\n      const audio = this.ensureAudio();\n      const duration = audio.duration;\n\n      if (Number.isNaN(duration)) {\n        return;\n      }\n\n      const isValidTime = time >= 0 && time <= duration;\n      const validTime = isValidTime\n        ? time\n        : Math.max(0, Math.min(time, duration));\n\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = validTime;\n      }\n    });\n  }\n\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    this.eventTarget.addEventListener(type, listener, options);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n\n  getSource(): string {\n    return (\n      this.ifClient(() => {\n        const audio = this.ensureAudio();\n        return audio.src;\n      }) ?? \"\"\n    );\n  }\n\n  isPaused(): boolean {\n    return (\n      this.ifClient(() => {\n        const audio = this.ensureAudio();\n        return audio.paused;\n      }) ?? true\n    );\n  }\n\n  getBufferedRanges(): TimeRanges | null {\n    if (!(this.isClient() && this.audio)) {\n      return null;\n    }\n    return this.audio.buffered;\n  }\n\n  setPlaybackRate(rate: number): void {\n    this.ifClient(() => {\n      const audio = this.ensureAudio();\n      const url = audio.src.toLowerCase();\n\n      // Check if current audio is a live stream using the same patterns as isLive()\n      const isLiveStream = LIVE_STREAM_PATTERNS.some((pattern) =>\n        pattern.test(url)\n      );\n\n      // Don't allow playback rate changes for live streams\n      if (isLiveStream) {\n        return;\n      }\n\n      const clampedRate = Math.max(0.25, Math.min(2, rate));\n      audio.playbackRate = clampedRate;\n    });\n  }\n\n  getPlaybackRate(): number {\n    return (\n      this.ifClient(() => {\n        const audio = this.ensureAudio();\n        return audio.playbackRate;\n      }) ?? 1\n    );\n  }\n}\n\nexport const $audio = new AudioLib();\n\nconst MINUTE_IN_SECONDS = 60;\n\nexport function isLive(track: Track): boolean {\n  if (!track.url) {\n    return false;\n  }\n\n  const url = track.url.toLowerCase();\n\n  for (const pattern of LIVE_STREAM_PATTERNS) {\n    if (pattern.test(url)) {\n      return true;\n    }\n  }\n\n  if (track.live === true) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function formatDuration(seconds: number): string {\n  if (!Number.isFinite(seconds) || seconds < 0) {\n    return \"0:00\";\n  }\n  const minutes = Math.floor(seconds / MINUTE_IN_SECONDS);\n  const remainingSeconds = Math.floor(seconds % MINUTE_IN_SECONDS);\n  return `${minutes}:${remainingSeconds < 10 ? \"0\" : \"\"}${remainingSeconds}`;\n}\n",
      "type": "registry:lib",
      "target": "lib/audio.ts"
    },
    {
      "path": "src/registry/default/lib/audio-store.ts",
      "content": "import { create } from \"zustand\";\nimport { persist, subscribeWithSelector } from \"zustand/middleware\";\nimport { $audio, isLive, type Track } from \"@/registry/default/lib/audio\";\n\ntype RepeatMode = \"none\" | \"one\" | \"all\";\ntype InsertMode = \"first\" | \"last\" | \"after\";\n\ntype AudioStore = {\n  // State\n  currentTrack: Track | null;\n  queue: Track[];\n  isPlaying: boolean;\n  isLoading: boolean;\n  isBuffering: boolean;\n  volume: number;\n  isMuted: boolean;\n  playbackRate: number;\n  repeatMode: RepeatMode;\n  shuffleEnabled: boolean;\n  currentTime: number;\n  duration: number;\n  progress: number;\n  bufferedTime: number;\n  insertMode: InsertMode;\n  isError: boolean;\n  errorMessage: string | null;\n  currentQueueIndex: number;\n\n  // Playback Actions\n  play: () => void;\n  pause: () => void;\n  togglePlay: () => void;\n  next: () => void;\n  previous: () => void;\n  seek: (time: number) => void;\n  setQueueAndPlay: (tracks: Track[], startIndex: number) => Promise<void>;\n  handleTrackEnd: () => void;\n\n  // Queue Actions\n  addToQueue: (track: Track, mode?: InsertMode) => void;\n  removeFromQueue: (trackId: string) => void;\n  clearQueue: () => void;\n  moveInQueue: (fromIndex: number, toIndex: number) => void;\n  setQueue: (tracks: Track[], startIndex?: number) => void;\n  getCurrentQueueIndex: () => number;\n  addTracksToEndOfQueue: (tracksToAdd: Track[]) => void;\n\n  // Control Actions\n  setVolume: (params: { volume: number }) => void;\n  toggleMute: () => void;\n  setPlaybackRate: (rate: number) => void;\n  changeRepeatMode: () => void;\n  setInsertMode: (mode: InsertMode) => void;\n  shuffle: () => void;\n  unshuffle: () => void;\n  setRepeatMode: (mode: RepeatMode) => void;\n\n  // State Actions\n  setCurrentTrack: (track: Track | null) => Promise<void>;\n  setError: (message: string | null) => void;\n};\n\nfunction canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n}\n\ntype QueueNavigationParams = {\n  queue: Track[];\n  currentQueueIndex: number;\n  shuffleEnabled: boolean;\n  repeatMode: RepeatMode;\n};\n\ntype GetRandomShuffleIndexParams = {\n  queueLength: number;\n  currentIndex: number;\n};\n\n/**\n * Calculates a random index for shuffle mode\n */\nconst getRandomShuffleIndex = (params: GetRandomShuffleIndexParams): number => {\n  const { queueLength, currentIndex } = params;\n  if (queueLength === 1) {\n    return 0;\n  }\n  let randomIndex: number;\n  do {\n    randomIndex = Math.floor(Math.random() * queueLength);\n  } while (randomIndex === currentIndex);\n  return randomIndex;\n};\n\ntype CalculateQueueIndexParams = QueueNavigationParams & {\n  direction: 1 | -1;\n};\n\n/**\n * Calculates the next or previous index in the queue based on direction\n */\nconst calculateQueueIndex = (params: CalculateQueueIndexParams): number => {\n  const { queue, currentQueueIndex, shuffleEnabled, repeatMode, direction } =\n    params;\n\n  if (queue.length === 0) {\n    return -1;\n  }\n\n  if (shuffleEnabled) {\n    const singleTrackIndex = repeatMode === \"none\" ? -1 : 0;\n    return queue.length === 1\n      ? singleTrackIndex\n      : getRandomShuffleIndex({\n          queueLength: queue.length,\n          currentIndex: currentQueueIndex,\n        });\n  }\n\n  const newIndex = currentQueueIndex + direction;\n  const isAtEnd = newIndex >= queue.length;\n  const isAtStart = newIndex < 0;\n\n  if (isAtEnd) {\n    return repeatMode === \"all\" ? 0 : -1;\n  }\n\n  if (isAtStart) {\n    return repeatMode === \"all\" ? queue.length - 1 : -1;\n  }\n\n  return newIndex;\n};\n\n/**\n * Calculates the index of the next track\n */\nconst calculateNextIndex = (params: QueueNavigationParams): number =>\n  calculateQueueIndex({\n    ...params,\n    direction: 1,\n  });\n\n/**\n * Calculates the index of the previous track\n */\nconst calculatePreviousIndex = (params: QueueNavigationParams): number =>\n  calculateQueueIndex({\n    ...params,\n    direction: -1,\n  });\n\n/**\n * Default state after successful track loading\n */\nconst getSuccessState = (params: { isPlaying?: boolean } = {}) => ({\n  isLoading: false,\n  isError: false,\n  errorMessage: null,\n  isBuffering: false,\n  isPlaying: params.isPlaying ?? false,\n});\n\n/**\n * Default state after loading error\n */\nconst getErrorState = (params: { errorMessage: string }) => ({\n  isLoading: false,\n  isPlaying: false,\n  isError: true,\n  errorMessage: params.errorMessage,\n  isBuffering: false,\n});\n\ntype LoadAndPlayTrackParams = {\n  track: Track;\n  queueIndex: number;\n  set: (partial: Partial<AudioStore>) => void;\n  get: () => AudioStore;\n  errorMessage: string;\n};\n\n/**\n * Loads and plays a track with error handling\n */\nconst loadAndPlayTrack = async (\n  params: LoadAndPlayTrackParams\n): Promise<void> => {\n  const { track, queueIndex, set, get, errorMessage } = params;\n  const isLiveStream = isLive(track);\n\n  set({\n    currentTrack: track,\n    currentQueueIndex: queueIndex,\n    isLoading: true,\n    isBuffering: true,\n  });\n\n  try {\n    await $audio.load({\n      url: track.url,\n      startTime: 0,\n      isLiveStream,\n    });\n\n    // Reset playback rate to 1.0 for live streams\n    if (isLiveStream) {\n      const currentState = get();\n      if (currentState.playbackRate !== 1) {\n        $audio.setPlaybackRate(1);\n        set({ playbackRate: 1 });\n      }\n    }\n\n    await $audio.play();\n    set(getSuccessState({ isPlaying: true }));\n  } catch (error) {\n    console.error(errorMessage, error);\n    set(getErrorState({ errorMessage }));\n    throw error;\n  }\n};\n\nconst useAudioStore = create<AudioStore>()(\n  persist(\n    subscribeWithSelector((set, get) => ({\n      // Initial State\n      currentTrack: null,\n      queue: [],\n      isPlaying: false,\n      isLoading: false,\n      isBuffering: false,\n      volume: 1,\n      isMuted: false,\n      playbackRate: 1,\n      repeatMode: \"none\",\n      shuffleEnabled: false,\n      currentTime: 0,\n      duration: 0,\n      progress: 0,\n      bufferedTime: 0,\n      insertMode: \"last\",\n      isError: false,\n      errorMessage: null,\n      currentQueueIndex: -1,\n\n      // Playback Actions\n      async play() {\n        if (get().isLoading) {\n          return;\n        }\n        await $audio.play();\n      },\n\n      pause() {\n        $audio.pause();\n      },\n\n      togglePlay() {\n        if (get().isLoading) {\n          return;\n        }\n        if ($audio.isPaused()) {\n          get().play();\n        } else {\n          get().pause();\n        }\n      },\n\n      async next() {\n        const state = get();\n        const nextIndex = calculateNextIndex({\n          queue: state.queue,\n          currentQueueIndex: state.currentQueueIndex,\n          shuffleEnabled: state.shuffleEnabled,\n          repeatMode: state.repeatMode,\n        });\n\n        const nextTrack = state.queue[nextIndex];\n        if (nextIndex === -1 || !nextTrack) {\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        await loadAndPlayTrack({\n          track: nextTrack,\n          queueIndex: nextIndex,\n          set,\n          get,\n          errorMessage: \"Error loading/playing next track\",\n        });\n      },\n\n      async previous() {\n        const state = get();\n        const currentTime = $audio.getCurrentTime();\n        const RESTART_THRESHOLD = 3;\n\n        // If track has more than 3 seconds and shuffle is not enabled, restart the track\n        if (currentTime > RESTART_THRESHOLD && !state.shuffleEnabled) {\n          set({ isLoading: true });\n          try {\n            $audio.setCurrentTime(0);\n            set({ currentTime: 0, progress: 0, isLoading: false });\n            return;\n          } catch (error) {\n            console.error(\"Error restarting current track:\", error);\n            set({ isLoading: false });\n            return;\n          }\n        }\n\n        const prevIndex = calculatePreviousIndex({\n          queue: state.queue,\n          currentQueueIndex: state.currentQueueIndex,\n          shuffleEnabled: state.shuffleEnabled,\n          repeatMode: state.repeatMode,\n        });\n\n        const prevTrack = state.queue[prevIndex];\n        if (prevIndex === -1 || !prevTrack) {\n          if (prevIndex !== -1) {\n            console.error(\n              \"Inconsistency: previous index is valid but track not found\"\n            );\n          }\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        await loadAndPlayTrack({\n          track: prevTrack,\n          queueIndex: prevIndex,\n          set,\n          get,\n          errorMessage: \"Error loading/playing previous track\",\n        });\n      },\n\n      seek(time: number) {\n        $audio.setCurrentTime(time);\n        set({ currentTime: time });\n      },\n\n      async setQueueAndPlay(songs: Track[], startIndex: number) {\n        const targetTrack = songs[startIndex];\n        if (!targetTrack) {\n          console.error(\"[Playback] Invalid startIndex for setQueueAndPlay\");\n          get().clearQueue();\n          $audio.pause();\n          set({\n            isPlaying: false,\n            isLoading: false,\n            currentTrack: null,\n            currentQueueIndex: -1,\n          });\n          return;\n        }\n\n        get().setQueue(songs, startIndex);\n\n        const errorMessage = `Error playing ${targetTrack.title || \"track\"}`;\n        await loadAndPlayTrack({\n          track: targetTrack,\n          queueIndex: startIndex,\n          set,\n          get,\n          errorMessage,\n        });\n      },\n\n      handleTrackEnd() {\n        get().next();\n      },\n\n      // Queue Actions\n      setQueue(tracks: Track[], startIndex = 0) {\n        const currentTrack = tracks[startIndex] ?? null;\n        set({\n          queue: tracks,\n          currentQueueIndex: currentTrack ? startIndex : -1,\n          currentTrack,\n        });\n      },\n\n      getCurrentQueueIndex() {\n        return get().currentQueueIndex;\n      },\n\n      addToQueue(track: Track, mode = \"last\") {\n        const state = get();\n        if (!state.currentTrack) {\n          set({\n            currentTrack: track,\n            currentQueueIndex: 0,\n            queue: [track],\n          });\n          return;\n        }\n\n        switch (mode) {\n          case \"first\":\n            set({\n              queue: [track, ...state.queue],\n              currentQueueIndex: state.currentQueueIndex + 1,\n            });\n            break;\n          case \"after\":\n            set({\n              queue: [\n                ...state.queue.slice(0, state.currentQueueIndex + 1),\n                track,\n                ...state.queue.slice(state.currentQueueIndex + 1),\n              ],\n            });\n            break;\n          default:\n            set({ queue: [...state.queue, track] });\n        }\n      },\n\n      removeFromQueue(trackId) {\n        const state = get();\n        const index = state.queue.findIndex((s) => s.id === trackId);\n        if (index === -1) {\n          return;\n        }\n\n        const newQueue = state.queue.filter((s) => s.id !== trackId);\n        set({\n          queue: newQueue,\n          currentQueueIndex:\n            index < state.currentQueueIndex\n              ? state.currentQueueIndex - 1\n              : state.currentQueueIndex,\n        });\n      },\n\n      clearQueue() {\n        set({ queue: [] });\n      },\n\n      moveInQueue(fromIndex, toIndex) {\n        const newQueue = [...get().queue];\n        const [movedItem] = newQueue.splice(fromIndex, 1);\n        if (!movedItem) {\n          return;\n        }\n\n        newQueue.splice(toIndex, 0, movedItem);\n        set({ queue: newQueue });\n      },\n\n      addTracksToEndOfQueue(tracksToAdd: Track[]) {\n        if (!tracksToAdd || tracksToAdd.length === 0) {\n          return;\n        }\n\n        const state = get();\n        const currentQueueIds = new Set(state.queue.map((s) => s.id));\n        const newTracks = tracksToAdd.filter(\n          (track) => !currentQueueIds.has(track.id)\n        );\n\n        if (newTracks.length > 0) {\n          set({ queue: [...state.queue, ...newTracks] });\n        }\n      },\n\n      // Control Actions\n      setVolume(params: { volume: number }) {\n        const { volume } = params;\n        $audio.setVolume({ volume });\n        set({ volume, isMuted: volume === 0 });\n      },\n\n      toggleMute() {\n        const newMuted = !get().isMuted;\n        $audio.setMuted(newMuted);\n        set({ isMuted: newMuted });\n      },\n\n      setPlaybackRate(rate: number) {\n        const state = get();\n        // Don't allow playback rate changes for live streams\n        if (state.currentTrack && isLive(state.currentTrack)) {\n          return;\n        }\n        const clampedRate = Math.max(0.25, Math.min(2, rate));\n        $audio.setPlaybackRate(clampedRate);\n        set({ playbackRate: clampedRate });\n      },\n\n      changeRepeatMode() {\n        const modes: RepeatMode[] = [\"none\", \"one\", \"all\"];\n        const currentIndex = modes.indexOf(get().repeatMode);\n        const newMode = modes[(currentIndex + 1) % modes.length];\n        set({ repeatMode: newMode });\n      },\n\n      setRepeatMode(mode) {\n        set({ repeatMode: mode });\n      },\n\n      setInsertMode(mode) {\n        set({ insertMode: mode });\n      },\n\n      shuffle() {\n        const state = get();\n        if (\n          !state.queue.length ||\n          state.queue.length < 2 ||\n          !state.currentTrack\n        ) {\n          return;\n        }\n\n        const remainingQueue = state.queue.filter(\n          (_, index) => index !== state.currentQueueIndex\n        );\n        const shuffledRemaining = remainingQueue.sort(\n          () => Math.random() - 0.5\n        );\n        const newQueue = [state.currentTrack, ...shuffledRemaining];\n\n        set({\n          queue: newQueue,\n          currentQueueIndex: 0,\n          shuffleEnabled: true,\n        });\n      },\n\n      unshuffle() {\n        set({ shuffleEnabled: false });\n      },\n\n      // State Actions\n      async setCurrentTrack(track: Track | null) {\n        const state = get();\n\n        if (!track) {\n          $audio.cleanup();\n          set({\n            currentTrack: null,\n            currentQueueIndex: -1,\n            isPlaying: false,\n            currentTime: 0,\n            duration: 0,\n            queue: [],\n            isLoading: false,\n            isError: false,\n            errorMessage: null,\n          });\n          return;\n        }\n\n        // Avoid reloading the same track\n        if (state.currentTrack?.id === track.id) {\n          return;\n        }\n\n        const errorMessage = `Error: ${track.title || \"Unknown track\"}`;\n\n        // Update queue with a single track\n        set({\n          currentTrack: track,\n          queue: [track],\n          currentQueueIndex: 0,\n          isLoading: true,\n          isPlaying: false,\n          currentTime: 0,\n          duration: 0,\n          isError: false,\n          errorMessage: null,\n        });\n\n        await loadAndPlayTrack({\n          track,\n          queueIndex: 0,\n          set,\n          get,\n          errorMessage,\n        });\n      },\n      setError: (message) => {\n        set({\n          isError: !!message,\n          errorMessage: message,\n          isLoading: false,\n          isPlaying: false,\n        });\n      },\n    })),\n    {\n      name: \"audio:ui:store\",\n      partialize: (state) => ({\n        currentTrack: state.currentTrack,\n        queue: state.queue,\n        volume: state.volume,\n        isMuted: state.isMuted,\n        playbackRate: state.playbackRate,\n        repeatMode: state.repeatMode,\n        shuffleEnabled: state.shuffleEnabled,\n        currentTime: state.currentTime,\n        insertMode: state.insertMode,\n        currentQueueIndex: state.currentQueueIndex,\n      }),\n    }\n  )\n);\n\nexport {\n  calculateNextIndex,\n  calculatePreviousIndex,\n  canUseDOM,\n  useAudioStore,\n  type AudioStore,\n  type RepeatMode,\n  type InsertMode,\n};\n",
      "type": "registry:lib",
      "target": "lib/audio-store.ts"
    },
    {
      "path": "src/registry/default/ui/slider.tsx",
      "content": "\"use client\";\n\nimport { Slider as SliderPrimitive } from \"radix-ui\";\nimport React from \"react\";\nimport { cn } from \"@/registry/default/lib/utils\";\n\ninterface SliderProps\n  extends React.ComponentProps<typeof SliderPrimitive.Root> {\n  bufferValue?: number;\n}\n\nfunction Slider({\n  className,\n  defaultValue,\n  value,\n  min = 0,\n  max = 100,\n  bufferValue,\n  ...props\n}: SliderProps) {\n  const _values = React.useMemo(() => {\n    if (Array.isArray(value)) {\n      return value;\n    }\n    if (Array.isArray(defaultValue)) {\n      return defaultValue;\n    }\n    return [min, max];\n  }, [value, defaultValue, min, max]);\n\n  return (\n    <SliderPrimitive.Root\n      className={cn(\n        \"relative flex w-full touch-none select-none items-center data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col data-disabled:opacity-50\",\n        className\n      )}\n      data-slot=\"slider\"\n      defaultValue={defaultValue}\n      max={max}\n      min={min}\n      value={value}\n      {...props}\n    >\n      <SliderPrimitive.Track\n        className={cn(\n          \"relative grow overflow-hidden rounded-full bg-muted data-[orientation=horizontal]:h-1.5 data-[orientation=vertical]:h-full data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-1.5\"\n        )}\n        data-slot=\"slider-track\"\n      >\n        <SliderPrimitive.Range\n          className={cn(\n            \"absolute bg-primary data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full\"\n          )}\n          data-slot=\"slider-range\"\n        />\n        {bufferValue !== undefined && (\n          <SliderPrimitive.Range\n            className=\"absolute z-0 bg-primary/40 data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full\"\n            data-slot=\"buffer-indicator\"\n            style={{\n              width: `${bufferValue || 0}%`,\n              transform: `translateX(-${100 - (bufferValue || 0)}%)`,\n            }}\n          />\n        )}\n      </SliderPrimitive.Track>\n      {Array.from({ length: _values.length }, (_, index) => (\n        <SliderPrimitive.Thumb\n          className=\"block size-4 shrink-0 rounded-full border border-primary bg-white shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\"\n          data-slot=\"slider-thumb\"\n          key={String(index)}\n        />\n      ))}\n    </SliderPrimitive.Root>\n  );\n}\nexport { Slider };\n",
      "type": "registry:component",
      "target": "components/audio/slider.tsx"
    }
  ]
}