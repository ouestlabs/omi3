{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "player",
  "type": "registry:block",
  "description": "Audio player",
  "dependencies": [
    "audio-engine",
    "@audio-ui/utils"
  ],
  "registryDependencies": [
    "@audio/player"
  ],
  "files": [
    {
      "path": "registry/default/particles/particle-player.tsx",
      "content": "\"use client\";\n\nimport { MusicalNoteAiIcon, MusicPlaylistIcon } from \"@audio-ui/icons\";\nimport { useAudio } from \"audio-engine/react\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/registry/default/ui/button\";\nimport {\n  Dialog,\n  DialogPopup,\n  DialogTrigger,\n} from \"@/registry/default/ui/dialog\";\nimport {\n  Empty,\n  EmptyDescription,\n  EmptyHeader,\n  EmptyMedia,\n  EmptyTitle,\n} from \"@/registry/default/ui/empty\";\nimport {\n  Frame,\n  FrameHeader,\n  FramePanel,\n  FrameTitle,\n} from \"@/registry/default/ui/frame\";\nimport { Group, GroupItem, GroupSeparator } from \"@/registry/default/ui/group\";\nimport { Input } from \"@/registry/default/ui/input\";\nimport {\n  Item,\n  ItemActions,\n  ItemContent,\n  ItemDescription,\n  ItemMedia,\n  ItemTitle,\n} from \"@/registry/default/ui/item\";\nimport {\n  exampleTracks,\n  NextButton,\n  Player,\n  PlayerDuration,\n  PlayerProgress,\n  PlayerSpeed,\n  PlayerTime,\n  PlayerTrackInfo,\n  PlayerVolume,\n  PlayPauseButton,\n  PreviousButton,\n  SkipBackwardButton,\n  SkipForwardButton,\n} from \"@/registry/default/ui/player\";\nimport { ScrollArea } from \"@/registry/default/ui/scroll-area\";\nimport { Toggle } from \"@/registry/default/ui/toggle\";\nimport { Waveform } from \"@/registry/default/ui/waveform\";\n\nconst WaveformVisualizer = ({\n  isDark,\n  precomputedWaveform,\n  waveformElementRef,\n  waveformOffset,\n  totalBars,\n  isScrubbing,\n  isMomentumActive,\n  audioData,\n}: {\n  isDark: boolean;\n  precomputedWaveform: number[];\n  waveformElementRef: React.RefObject<HTMLDivElement | null>;\n  waveformOffset: React.RefObject<number>;\n  totalBars: React.RefObject<number>;\n  isScrubbing: boolean;\n  isMomentumActive: boolean;\n  audioData: number[];\n}) => {\n  useEffect(() => {\n    if (waveformElementRef.current) {\n      waveformElementRef.current.style.transform = `translateX(${waveformOffset.current}px)`;\n      waveformElementRef.current.style.transition =\n        isScrubbing || isMomentumActive ? \"none\" : \"transform 0.016s linear\";\n    }\n  }, [waveformElementRef, waveformOffset, isScrubbing, isMomentumActive]);\n\n  return (\n    <div\n      ref={waveformElementRef}\n      style={{\n        transform: `translateX(${waveformOffset.current}px)`,\n        transition:\n          isScrubbing || isMomentumActive ? \"none\" : \"transform 0.016s linear\",\n        width: `${totalBars.current * 5}px`,\n        position: \"absolute\",\n        left: 0,\n      }}\n    >\n      <Waveform\n        barColor={isDark ? \"#a1a1aa\" : \"#71717a\"}\n        barGap={2}\n        barRadius={1}\n        barWidth={3}\n        data={precomputedWaveform.length > 0 ? precomputedWaveform : audioData}\n        fadeEdges={true}\n        fadeWidth={24}\n        height={32}\n        key={isDark ? \"dark\" : \"light\"}\n      />\n    </div>\n  );\n};\n\nWaveformVisualizer.displayName = \"Waveform.Visualizer\";\n\n// Track item component\nconst TrackListItem = function TrackListItem({\n  track,\n  index,\n  isActive,\n  onPlay,\n}: {\n  track: {\n    id: string | number;\n    title?: string;\n    artist?: string;\n    url: string;\n    data?: unknown;\n  };\n  index: number;\n  isActive: boolean;\n  onPlay: (index: number) => void;\n}) {\n  const handleClick = useCallback(\n    (e: React.MouseEvent) => {\n      onPlay(index);\n      e.preventDefault();\n    },\n    [index, onPlay]\n  );\n\n  return (\n    <Item\n      className={cn(\"w-full px-2 py-1 transition-all hover:bg-secondary/50\")}\n      onClick={handleClick}\n      size=\"sm\"\n      variant={isActive ? \"muted\" : \"default\"}\n    >\n      <ItemMedia>\n        <span className=\"line-height-none text-muted-foreground/60 text-xs\">\n          {index + 1}\n        </span>\n      </ItemMedia>\n      <ItemContent className=\"min-w-0 flex-1 gap-0 overflow-hidden\">\n        <ItemTitle className=\"truncate font-medium text-sm leading-snug\">\n          {track.title}\n        </ItemTitle>\n        <ItemDescription>{track.artist}</ItemDescription>\n      </ItemContent>\n      {isActive && (\n        <ItemActions>\n          <PlayPauseButton\n            item={track}\n            onClick={(e) => {\n              e.stopPropagation();\n              e.preventDefault();\n            }}\n            size=\"icon\"\n            variant=\"ghost\"\n          />\n        </ItemActions>\n      )}\n    </Item>\n  );\n};\n\nfunction Widget({ className }: { className?: string }) {\n  const audio = useAudio();\n  const engine = audio.state.status.engine;\n  const isPlaying = audio.state.playback.isPlaying;\n  const activeItemId = audio.state.queue.activeItemId;\n  const play = audio.actions.playback.play;\n  const pause = audio.actions.playback.pause;\n  const setQueue = audio.actions.queue.setQueue;\n  const setActiveItem = audio.actions.queue.setActiveItem;\n  const [currentTrackIndex, setCurrentTrackIndex] = useState(0);\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [isDark, setIsDark] = useState(false);\n  const [precomputedWaveform, setPrecomputedWaveform] = useState<number[]>([]);\n  const [ambienceMode, setAmbienceMode] = useState(false);\n  const [isScrubbing, setIsScrubbing] = useState(false);\n  const [isMomentumActive, setIsMomentumActive] = useState(false);\n  const [audioData, setAudioData] = useState<number[]>([]);\n  const containerWidthRef = useRef(300);\n  const audioBufferRef = useRef<AudioBuffer | null>(null);\n  const totalBarsRef = useRef(600);\n  const waveformOffset = useRef(0);\n  const waveformElementRef = useRef<HTMLDivElement>(null);\n  const scratchBufferRef = useRef<AudioBufferSourceNode | null>(null);\n  const isPlayingRef = useRef(false);\n  const isScrubbingRef = useRef(false);\n  const isMomentumActiveRef = useRef(false);\n\n  useEffect(() => {\n    const checkTheme = () => {\n      const isDarkMode = document.documentElement.classList.contains(\"dark\");\n      setIsDark(isDarkMode);\n    };\n\n    checkTheme();\n\n    const observer = new MutationObserver(checkTheme);\n    observer.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter: [\"class\"],\n    });\n\n    return () => observer.disconnect();\n  }, []);\n\n  useEffect(() => {\n    const container = document.querySelector(\".waveform-container\");\n    if (container) {\n      const rect = container.getBoundingClientRect();\n      containerWidthRef.current = rect.width;\n      waveformOffset.current = rect.width;\n      if (waveformElementRef.current) {\n        waveformElementRef.current.style.transform = `translateX(${rect.width}px)`;\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    if (precomputedWaveform.length === 0 || containerWidthRef.current === 0) {\n      return;\n    }\n\n    const audioEl = audio.state.status.audioElement;\n    if (!audioEl) {\n      return;\n    }\n\n    const calculateInitialOffset = () => {\n      if (!Number.isNaN(audioEl.duration) && audioEl.duration > 0) {\n        const currentTime = audioEl.currentTime;\n        const duration = audioEl.duration;\n        const position = Math.max(0, Math.min(1, currentTime / duration));\n        const totalWidth = totalBarsRef.current * 5;\n        return containerWidthRef.current - position * totalWidth;\n      }\n      return containerWidthRef.current;\n    };\n\n    const initialOffset = calculateInitialOffset();\n    waveformOffset.current = initialOffset;\n    if (waveformElementRef.current) {\n      waveformElementRef.current.style.transform = `translateX(${initialOffset}px)`;\n    }\n\n    if (Number.isNaN(audioEl.duration) || audioEl.duration <= 0) {\n      audioEl.currentTime = 0;\n    }\n  }, [precomputedWaveform, audio.state.status.audioElement]);\n\n  const processChannelDataToWaveform = useCallback(\n    (channelData: Float32Array, totalBars: number): number[] => {\n      const samplesPerBar = Math.floor(channelData.length / totalBars);\n      const waveformData: number[] = [];\n\n      for (let i = 0; i < totalBars; i++) {\n        const start = i * samplesPerBar;\n        const end = start + samplesPerBar;\n        let sum = 0;\n        let count = 0;\n\n        for (let j = start; j < end && j < channelData.length; j += 100) {\n          const sample = channelData[j];\n          if (sample !== undefined) {\n            sum += Math.abs(sample);\n            count++;\n          }\n        }\n\n        const average = count > 0 ? sum / count : 0;\n        waveformData.push(Math.min(1, average * 3));\n      }\n\n      return waveformData;\n    },\n    []\n  );\n\n  const precomputeWaveform = useCallback(\n    async (audioUrl: string) => {\n      try {\n        const response = await fetch(audioUrl);\n        const arrayBuffer = await response.arrayBuffer();\n\n        const offlineContext = new OfflineAudioContext(1, 44_100 * 5, 44_100);\n        const offlineBuffer = await offlineContext.decodeAudioData(\n          arrayBuffer.slice(0)\n        );\n\n        const audioContext = audio.state.status.audioContext;\n        if (!audioContext) {\n          console.warn(\"Audio context not available yet\");\n          return;\n        }\n\n        if (audioContext.state === \"suspended\") {\n          await audioContext.resume();\n        }\n\n        audioBufferRef.current =\n          await audioContext.decodeAudioData(arrayBuffer);\n\n        const channelData = offlineBuffer.getChannelData(0);\n        const waveformData = processChannelDataToWaveform(\n          channelData,\n          totalBarsRef.current\n        );\n\n        setPrecomputedWaveform(waveformData);\n      } catch (error) {\n        console.error(\"Error precomputing waveform:\", error);\n      }\n    },\n    [processChannelDataToWaveform, audio.state.status.audioContext]\n  );\n\n  useEffect(() => {\n    setQueue(exampleTracks);\n    const firstTrack = exampleTracks[0];\n    if (firstTrack) {\n      setActiveItem(firstTrack.id);\n      precomputeWaveform(firstTrack.url);\n    }\n  }, [precomputeWaveform, setQueue, setActiveItem]);\n\n  useEffect(() => {\n    const handlePlay = () => {\n      isPlayingRef.current = true;\n    };\n    const handlePause = () => {\n      isPlayingRef.current = false;\n    };\n\n    const checkInterval = setInterval(() => {\n      const audioEl = audio.state.status.audioElement;\n      if (audioEl) {\n        clearInterval(checkInterval);\n\n        audioEl.addEventListener(\"play\", handlePlay);\n        audioEl.addEventListener(\"pause\", handlePause);\n        audioEl.addEventListener(\"ended\", handlePause);\n\n        if (!audioEl.paused) {\n          handlePlay();\n        }\n      }\n    }, 100);\n\n    return () => {\n      clearInterval(checkInterval);\n      const audioEl = audio.state.status.audioElement;\n      if (audioEl) {\n        audioEl.removeEventListener(\"play\", handlePlay);\n        audioEl.removeEventListener(\"pause\", handlePause);\n        audioEl.removeEventListener(\"ended\", handlePause);\n      }\n    };\n  }, [audio.state.status.audioElement]);\n\n  useEffect(() => {\n    let animationId: number;\n\n    const updateWaveform = () => {\n      const analyserNode = audio.state.status.analyserNode;\n      const ctx = audio.state.status.audioContext;\n      const currentlyPlaying = audio.state.playback.isPlaying;\n\n      // S'assurer que l'audio context est actif avant de lire les données\n      if (analyserNode && ctx && currentlyPlaying) {\n        // Reprendre l'audio context s'il est suspendu\n        if (ctx.state === \"suspended\") {\n          ctx.resume().catch((error) => {\n            console.error(\"Failed to resume audio context:\", error);\n          });\n        }\n\n        const dataArray = new Uint8Array(analyserNode.frequencyBinCount);\n        analyserNode.getByteFrequencyData(dataArray);\n\n        const normalizedData = Array.from(dataArray).map((value) => {\n          const normalized = value / 255;\n          return normalized;\n        });\n\n        setAudioData(normalizedData);\n      } else if (!currentlyPlaying) {\n        setAudioData((prev) => {\n          if (prev.length > 0) {\n            return prev.map((v) => v * 0.9);\n          }\n          return prev;\n        });\n      }\n\n      animationId = requestAnimationFrame(updateWaveform);\n    };\n\n    animationId = requestAnimationFrame(updateWaveform);\n\n    return () => {\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n    };\n  }, [\n    audio.state.status.analyserNode,\n    audio.state.status.audioContext,\n    audio.state.playback.isPlaying,\n  ]);\n\n  useEffect(() => {\n    isScrubbingRef.current = isScrubbing;\n  }, [isScrubbing]);\n\n  useEffect(() => {\n    isMomentumActiveRef.current = isMomentumActive;\n  }, [isMomentumActive]);\n\n  const stopScratchSound = useCallback(() => {\n    if (scratchBufferRef.current) {\n      try {\n        scratchBufferRef.current.stop();\n      } catch {\n        // Already stopped\n      }\n      scratchBufferRef.current = null;\n    }\n  }, []);\n\n  const playScratchSound = useCallback(\n    (position: number, speed = 1) => {\n      if (!audio.state.status.audioContext) {\n        return;\n      }\n\n      if (audio.state.status.audioContext.state === \"suspended\") {\n        audio.state.status.audioContext.resume();\n      }\n\n      if (!audioBufferRef.current) {\n        return;\n      }\n\n      stopScratchSound();\n\n      try {\n        const source = audio.state.status.audioContext.createBufferSource();\n        source.buffer = audioBufferRef.current;\n\n        const startTime = Math.max(\n          0,\n          Math.min(\n            audioBufferRef.current.duration - 0.1,\n            position * audioBufferRef.current.duration\n          )\n        );\n\n        const filter = audio.state.status.audioContext.createBiquadFilter();\n        filter.type = \"lowpass\";\n        filter.frequency.value = Math.max(800, 2500 - speed * 1500);\n        filter.Q.value = 3;\n\n        source.playbackRate.value = Math.max(\n          0.4,\n          Math.min(2.5, 1 + speed * 0.5)\n        );\n\n        const gainNode = audio.state.status.audioContext.createGain();\n        gainNode.gain.value = 1.0;\n\n        source.connect(filter);\n        filter.connect(gainNode);\n        gainNode.connect(audio.state.status.audioContext.destination);\n\n        source.start(0, startTime, 0.06);\n\n        scratchBufferRef.current = source;\n      } catch (error) {\n        console.error(\"Error playing scratch sound:\", error);\n      }\n    },\n    [stopScratchSound, audio.state.status.audioContext]\n  );\n\n  const effects = useMemo(\n    () => [\n      {\n        id: \"reverb\",\n        type: \"reverb\" as const,\n        enabled: true,\n        roomSize: 6,\n        decay: 1.5,\n        wet: ambienceMode ? 0.85 : 0,\n        dry: ambienceMode ? 0.4 : 1,\n      },\n      {\n        id: \"delay\",\n        type: \"delay\" as const,\n        enabled: true,\n        delayTime: ambienceMode ? 0.25 : 0.001,\n        feedback: ambienceMode ? 0.25 : 0.05,\n      },\n      {\n        id: \"highpass\",\n        type: \"filter\" as const,\n        enabled: true,\n        filterType: \"highpass\" as const,\n        frequency: ambienceMode ? 200 : 100,\n        Q: 0.7,\n      },\n      {\n        id: \"lowpass\",\n        type: \"filter\" as const,\n        enabled: true,\n        filterType: \"lowpass\" as const,\n        frequency: ambienceMode ? 800 : 1500,\n        Q: ambienceMode ? 0.7 : 0.5,\n      },\n      {\n        id: \"compressor\",\n        type: \"compressor\" as const,\n        enabled: true,\n        threshold: -12,\n        knee: 2,\n        ratio: 8,\n        attack: 0.003,\n        release: 0.1,\n      },\n    ],\n    [ambienceMode]\n  );\n\n  useEffect(() => {\n    audio.effects.apply(effects);\n  }, [audio.effects, effects]);\n\n  const currentPosition = useMemo(() => {\n    const { currentTime, duration } = {\n      currentTime: audio.state.playback.currentTime,\n      duration: audio.state.playback.duration,\n    };\n    if (\n      !Number.isFinite(duration) ||\n      duration <= 0 ||\n      !Number.isFinite(currentTime)\n    ) {\n      return 0;\n    }\n    return Math.max(\n      0,\n      Math.min(100, Math.round((currentTime / duration) * 100))\n    );\n  }, [audio.state.playback.currentTime, audio.state.playback.duration]);\n\n  useEffect(() => {\n    const canStartAnimation =\n      !(isScrubbing || isMomentumActive) &&\n      audio.state.status.audioElement !== null;\n    if (!canStartAnimation) {\n      return;\n    }\n\n    let animationId: number;\n\n    const updatePosition = () => {\n      const audioEl = audio.state.status.audioElement;\n      if (\n        audioEl &&\n        !isScrubbing &&\n        !isMomentumActive &&\n        waveformElementRef.current\n      ) {\n        const duration = audioEl.duration;\n        const currentTime = audioEl.currentTime;\n\n        if (!Number.isNaN(duration) && duration > 0) {\n          const position = currentTime / duration;\n          const containerWidth = containerWidthRef.current;\n          const totalWidth = totalBarsRef.current * 5;\n          const newOffset = containerWidth - position * totalWidth;\n\n          waveformOffset.current = newOffset;\n          waveformElementRef.current.style.transform = `translateX(${newOffset}px)`;\n        }\n      }\n      animationId = requestAnimationFrame(updatePosition);\n    };\n\n    animationId = requestAnimationFrame(updatePosition);\n    return () => {\n      if (animationId) {\n        cancelAnimationFrame(animationId);\n      }\n    };\n  }, [audio.state.status.audioElement, isScrubbing, isMomentumActive]);\n\n  const playTrack = useCallback(\n    (index: number) => {\n      const exampleTrack = exampleTracks[index];\n      if (!exampleTrack) {\n        return;\n      }\n      setCurrentTrackIndex(index);\n      const track = {\n        id: exampleTrack.id,\n        title: exampleTrack.title,\n        url: exampleTrack.url,\n        data: exampleTrack.data,\n      };\n      play(track);\n      precomputeWaveform(track.url);\n      setDialogOpen(false);\n    },\n    [play, precomputeWaveform]\n  );\n\n  const tracks = useMemo(\n    () =>\n      exampleTracks.map((t) => ({\n        id: t.id,\n        title: t.title,\n        artist: \"Audio UI\",\n        url: t.url,\n        data: t.data,\n      })),\n    []\n  );\n  const filteredTracks = useMemo(() => {\n    if (!searchQuery.trim()) {\n      return tracks;\n    }\n    const query = searchQuery.toLowerCase();\n    return tracks.filter(\n      (track) =>\n        track.title?.toLowerCase().includes(query) ||\n        track.artist?.toLowerCase().includes(query)\n    );\n  }, [tracks, searchQuery]);\n\n  const currentQueueItem = useMemo(() => {\n    const track = exampleTracks[currentTrackIndex];\n    if (!track) {\n      return;\n    }\n    return {\n      id: track.id,\n      title: track.title,\n      url: track.url,\n      data: track.data,\n    };\n  }, [currentTrackIndex]);\n\n  const playPauseVariant = useMemo(\n    () =>\n      isPlaying && activeItemId === exampleTracks[currentTrackIndex]?.id\n        ? \"outline\"\n        : \"default\",\n    [isPlaying, activeItemId, currentTrackIndex]\n  );\n\n  return (\n    <Frame className={cn(\"relative\", className)}>\n      <FrameHeader>\n        <FrameTitle>Player</FrameTitle>\n      </FrameHeader>\n      <FramePanel className=\"relative space-y-6\">\n        <div className=\"space-y-2\">\n          <div className=\"flex items-center justify-end\">\n            <Group>\n              <GroupItem render={<PlayerSpeed />} />\n              <GroupSeparator />\n\n              <Dialog\n                onOpenChange={(open) => {\n                  setDialogOpen(open);\n                  if (!open) {\n                    setSearchQuery(\"\");\n                  }\n                }}\n                open={dialogOpen}\n              >\n                <DialogTrigger\n                  render={\n                    <GroupItem\n                      render={<Button size=\"icon\" variant=\"outline\" />}\n                    />\n                  }\n                >\n                  <MusicPlaylistIcon />\n                </DialogTrigger>\n                <DialogPopup\n                  aria-label=\"Sélectionner une piste\"\n                  className=\"p-0!\"\n                  showCloseButton={false}\n                >\n                  <Frame>\n                    <FrameHeader>\n                      <Input\n                        onChange={(e) => setSearchQuery(e.target.value)}\n                        placeholder=\"Rechercher une piste...\"\n                        type=\"search\"\n                        value={searchQuery}\n                      />\n                    </FrameHeader>\n\n                    <FramePanel className=\"p-1.5!\">\n                      <ScrollArea className=\"no-scrollbar max-h-[50vh] space-y-1 p-3\">\n                        {filteredTracks.length > 0 ? (\n                          filteredTracks.map((track) => {\n                            const index = tracks.findIndex(\n                              (t) => t.id === track.id\n                            );\n                            return (\n                              <TrackListItem\n                                index={index}\n                                isActive={currentTrackIndex === index}\n                                key={track.id}\n                                onPlay={playTrack}\n                                track={track}\n                              />\n                            );\n                          })\n                        ) : (\n                          <Empty className=\"flex h-full flex-col items-center justify-center gap-3 border bg-muted/20 p-3\">\n                            <EmptyHeader>\n                              <EmptyMedia variant=\"icon\">\n                                <MusicPlaylistIcon className=\"size-6\" />\n                              </EmptyMedia>\n                              <EmptyTitle>No tracks found</EmptyTitle>\n                              <EmptyDescription>\n                                Try searching for a different track.\n                              </EmptyDescription>\n                            </EmptyHeader>\n                          </Empty>\n                        )}\n                      </ScrollArea>\n                    </FramePanel>\n                  </Frame>\n                </DialogPopup>\n              </Dialog>\n              <GroupSeparator />\n              <GroupItem\n                render={\n                  <Toggle\n                    onClick={() => setAmbienceMode(!ambienceMode)}\n                    variant=\"outline\"\n                  />\n                }\n              >\n                <MusicalNoteAiIcon />\n              </GroupItem>\n            </Group>\n          </div>\n\n          <div\n            aria-label=\"Audio playback position\"\n            aria-valuemax={100}\n            aria-valuemin={0}\n            aria-valuenow={currentPosition}\n            className=\"waveform-container relative h-12 cursor-grab overflow-hidden rounded-lg bg-foreground/10 p-2 active:cursor-grabbing dark:bg-black/80\"\n            onMouseDown={(e) => {\n              e.preventDefault();\n              setIsScrubbing(true);\n\n              const wasPlaying = isPlayingRef.current;\n\n              if (isPlayingRef.current) {\n                pause();\n              }\n\n              const rect = e.currentTarget.getBoundingClientRect();\n              const startX = e.clientX;\n              const containerWidth = rect.width;\n              containerWidthRef.current = containerWidth;\n              const totalWidth = totalBarsRef.current * 5;\n              const currentOffset = waveformOffset.current;\n              let lastMouseX = startX;\n              let lastScratchTime = 0;\n              const scratchThrottle = 10;\n\n              let velocity = 0;\n              let lastTime = Date.now();\n              let lastClientX = e.clientX;\n\n              const handleMove = (moveEvent: MouseEvent) => {\n                const deltaX = moveEvent.clientX - startX;\n                const newOffset = currentOffset + deltaX;\n\n                const minOffset = containerWidth - totalWidth;\n                const maxOffset = containerWidth;\n                const clampedOffset = Math.max(\n                  minOffset,\n                  Math.min(maxOffset, newOffset)\n                );\n                waveformOffset.current = clampedOffset;\n                if (waveformElementRef.current) {\n                  waveformElementRef.current.style.transform = `translateX(${clampedOffset}px)`;\n                }\n\n                const position = Math.max(\n                  0,\n                  Math.min(1, (containerWidth - clampedOffset) / totalWidth)\n                );\n\n                const audioEl = audio.state.status.audioElement;\n                if (audioEl && !Number.isNaN(audioEl.duration)) {\n                  audioEl.currentTime = position * audioEl.duration;\n                }\n\n                const now = Date.now();\n                const mouseDelta = moveEvent.clientX - lastMouseX;\n\n                const timeDelta = now - lastTime;\n                if (timeDelta > 0) {\n                  const instantVelocity =\n                    (moveEvent.clientX - lastClientX) / timeDelta;\n                  velocity = velocity * 0.6 + instantVelocity * 0.4;\n                }\n                lastTime = now;\n                lastClientX = moveEvent.clientX;\n\n                if (\n                  Math.abs(mouseDelta) > 0 &&\n                  now - lastScratchTime >= scratchThrottle\n                ) {\n                  const speed = Math.min(3, Math.abs(mouseDelta) / 3);\n                  playScratchSound(position, speed);\n                  lastScratchTime = now;\n                }\n                lastMouseX = moveEvent.clientX;\n              };\n\n              const handleUp = () => {\n                setIsScrubbing(false);\n                stopScratchSound();\n\n                if (Math.abs(velocity) > 0.1) {\n                  setIsMomentumActive(true);\n                  let momentumOffset = waveformOffset.current;\n                  let currentVelocity = velocity * 15;\n                  const friction = 0.92;\n                  const minVelocity = 0.5;\n                  let lastScratchFrame = 0;\n                  const scratchFrameInterval = 50;\n\n                  const clampMomentumOffset = (\n                    offset: number\n                  ): { clamped: number; hitBoundary: boolean } => {\n                    const minOffset = containerWidth - totalWidth;\n                    const maxOffset = containerWidth;\n                    const clamped = Math.max(\n                      minOffset,\n                      Math.min(maxOffset, offset)\n                    );\n                    return {\n                      clamped,\n                      hitBoundary: clamped !== offset,\n                    };\n                  };\n\n                  const updateWaveformAndAudio = (offset: number) => {\n                    waveformOffset.current = offset;\n                    if (waveformElementRef.current) {\n                      waveformElementRef.current.style.transform = `translateX(${offset}px)`;\n                    }\n\n                    const position = Math.max(\n                      0,\n                      Math.min(1, (containerWidth - offset) / totalWidth)\n                    );\n\n                    const audioEl = engine?.audioElement;\n                    if (audioEl && !Number.isNaN(audioEl.duration)) {\n                      audioEl.currentTime = position * audioEl.duration;\n                    }\n\n                    return position;\n                  };\n\n                  const handleMomentumScratchSound = (\n                    position: number,\n                    vel: number,\n                    now: number\n                  ) => {\n                    if (now - lastScratchFrame >= scratchFrameInterval) {\n                      const speed = Math.min(2.5, Math.abs(vel) / 10);\n                      if (speed > 0.1) {\n                        playScratchSound(position, speed);\n                      }\n                      lastScratchFrame = now;\n                    }\n                  };\n\n                  const stopMomentum = () => {\n                    stopScratchSound();\n                    setIsMomentumActive(false);\n                    if (wasPlaying) {\n                      setTimeout(() => {\n                        play();\n                      }, 10);\n                    }\n                  };\n\n                  const animateMomentum = () => {\n                    if (Math.abs(currentVelocity) > minVelocity) {\n                      momentumOffset += currentVelocity;\n                      currentVelocity *= friction;\n\n                      const { clamped, hitBoundary } =\n                        clampMomentumOffset(momentumOffset);\n                      if (hitBoundary) {\n                        currentVelocity = 0;\n                      }\n\n                      momentumOffset = clamped;\n                      const position = updateWaveformAndAudio(clamped);\n\n                      const now = Date.now();\n                      handleMomentumScratchSound(\n                        position,\n                        currentVelocity,\n                        now\n                      );\n\n                      requestAnimationFrame(animateMomentum);\n                    } else {\n                      stopMomentum();\n                    }\n                  };\n\n                  requestAnimationFrame(animateMomentum);\n                } else if (wasPlaying) {\n                  play();\n                }\n\n                document.removeEventListener(\"mousemove\", handleMove);\n                document.removeEventListener(\"mouseup\", handleUp);\n              };\n\n              document.addEventListener(\"mousemove\", handleMove);\n              document.addEventListener(\"mouseup\", handleUp);\n            }}\n            onTouchStart={(e) => {\n              e.preventDefault();\n              setIsScrubbing(true);\n\n              const wasPlaying = isPlayingRef.current;\n\n              if (isPlayingRef.current) {\n                pause();\n              }\n\n              const touch = e.touches[0];\n              if (!touch) {\n                return;\n              }\n\n              const rect = e.currentTarget.getBoundingClientRect();\n              const startX = touch.clientX;\n              const containerWidth = rect.width;\n              containerWidthRef.current = containerWidth;\n              const totalWidth = totalBarsRef.current * 5;\n              const currentOffset = waveformOffset.current;\n              let lastTouchX = startX;\n              let lastScratchTime = 0;\n              const scratchThrottle = 10;\n\n              let velocity = 0;\n              let lastTime = Date.now();\n              let lastClientX = touch.clientX;\n\n              const clampTouchOffset = (offset: number) => {\n                const minOffset = containerWidth - totalWidth;\n                const maxOffset = containerWidth;\n                return Math.max(minOffset, Math.min(maxOffset, offset));\n              };\n\n              const updateTouchWaveformAndAudio = (offset: number) => {\n                waveformOffset.current = offset;\n                if (waveformElementRef.current) {\n                  waveformElementRef.current.style.transform = `translateX(${offset}px)`;\n                }\n\n                const position = Math.max(\n                  0,\n                  Math.min(1, (containerWidth - offset) / totalWidth)\n                );\n\n                const audioEl = audio.state.status.audioElement;\n                if (audioEl && !Number.isNaN(audioEl.duration)) {\n                  audioEl.currentTime = position * audioEl.duration;\n                }\n\n                return position;\n              };\n\n              const updateTouchVelocity = (\n                clientX: number,\n                now: number\n              ): number => {\n                const timeDelta = now - lastTime;\n                if (timeDelta > 0) {\n                  const instantVelocity = (clientX - lastClientX) / timeDelta;\n                  velocity = velocity * 0.6 + instantVelocity * 0.4;\n                }\n                lastTime = now;\n                lastClientX = clientX;\n                return velocity;\n              };\n\n              const handleMove = (moveEvent: TouchEvent) => {\n                const moveTouch = moveEvent.touches[0];\n                if (!moveTouch) {\n                  return;\n                }\n                const deltaX = moveTouch.clientX - startX;\n                const newOffset = currentOffset + deltaX;\n                const clampedOffset = clampTouchOffset(newOffset);\n                const position = updateTouchWaveformAndAudio(clampedOffset);\n\n                const now = Date.now();\n                updateTouchVelocity(moveTouch.clientX, now);\n\n                const touchDelta = moveTouch.clientX - lastTouchX;\n                if (\n                  Math.abs(touchDelta) > 0 &&\n                  now - lastScratchTime >= scratchThrottle\n                ) {\n                  const speed = Math.min(3, Math.abs(touchDelta) / 3);\n                  playScratchSound(position, speed);\n                  lastScratchTime = now;\n                }\n                lastTouchX = moveTouch.clientX;\n              };\n\n              const handleEnd = () => {\n                setIsScrubbing(false);\n                stopScratchSound();\n\n                if (Math.abs(velocity) > 0.1) {\n                  setIsMomentumActive(true);\n                  let momentumOffset = waveformOffset.current;\n                  let currentVelocity = velocity * 15;\n                  const friction = 0.92;\n                  const minVelocity = 0.5;\n                  let lastScratchFrame = 0;\n                  const scratchFrameInterval = 50;\n\n                  const clampMomentumOffset = (\n                    offset: number\n                  ): { clamped: number; hitBoundary: boolean } => {\n                    const minOffset = containerWidth - totalWidth;\n                    const maxOffset = containerWidth;\n                    const clamped = Math.max(\n                      minOffset,\n                      Math.min(maxOffset, offset)\n                    );\n                    return {\n                      clamped,\n                      hitBoundary: clamped !== offset,\n                    };\n                  };\n\n                  const updateWaveformAndAudio = (offset: number) => {\n                    waveformOffset.current = offset;\n                    if (waveformElementRef.current) {\n                      waveformElementRef.current.style.transform = `translateX(${offset}px)`;\n                    }\n\n                    const position = Math.max(\n                      0,\n                      Math.min(1, (containerWidth - offset) / totalWidth)\n                    );\n\n                    const audioEl = engine?.audioElement;\n                    if (audioEl && !Number.isNaN(audioEl.duration)) {\n                      audioEl.currentTime = position * audioEl.duration;\n                    }\n\n                    return position;\n                  };\n\n                  const handleMomentumScratchSound = (\n                    position: number,\n                    vel: number,\n                    now: number\n                  ) => {\n                    if (now - lastScratchFrame >= scratchFrameInterval) {\n                      const speed = Math.min(2.5, Math.abs(vel) / 10);\n                      if (speed > 0.1) {\n                        playScratchSound(position, speed);\n                      }\n                      lastScratchFrame = now;\n                    }\n                  };\n\n                  const stopMomentum = () => {\n                    stopScratchSound();\n                    setIsMomentumActive(false);\n                    if (wasPlaying) {\n                      setTimeout(() => {\n                        play();\n                      }, 10);\n                    }\n                  };\n\n                  const animateMomentum = () => {\n                    if (Math.abs(currentVelocity) > minVelocity) {\n                      momentumOffset += currentVelocity;\n                      currentVelocity *= friction;\n\n                      const { clamped, hitBoundary } =\n                        clampMomentumOffset(momentumOffset);\n                      if (hitBoundary) {\n                        currentVelocity = 0;\n                      }\n\n                      momentumOffset = clamped;\n                      const position = updateWaveformAndAudio(clamped);\n\n                      const now = Date.now();\n                      handleMomentumScratchSound(\n                        position,\n                        currentVelocity,\n                        now\n                      );\n\n                      requestAnimationFrame(animateMomentum);\n                    } else {\n                      stopMomentum();\n                    }\n                  };\n\n                  requestAnimationFrame(animateMomentum);\n                } else if (wasPlaying) {\n                  play();\n                }\n\n                document.removeEventListener(\"touchmove\", handleMove);\n                document.removeEventListener(\"touchend\", handleEnd);\n              };\n\n              document.addEventListener(\"touchmove\", handleMove);\n              document.addEventListener(\"touchend\", handleEnd);\n            }}\n            role=\"slider\"\n            tabIndex={0}\n          >\n            <div className=\"relative h-full w-full overflow-hidden\">\n              <WaveformVisualizer\n                audioData={audioData}\n                isDark={isDark}\n                isMomentumActive={isMomentumActive}\n                isScrubbing={isScrubbing}\n                precomputedWaveform={precomputedWaveform}\n                totalBars={totalBarsRef}\n                waveformElementRef={waveformElementRef}\n                waveformOffset={waveformOffset}\n              />\n            </div>\n          </div>\n          <div className=\"flex w-full items-center justify-center gap-2\">\n            <PlayerTime className=\"text-xs\" />\n            <PlayerProgress className=\"flex-1\" />\n            <PlayerDuration className=\"text-xs\" />\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <PlayerTrackInfo />\n            <div className=\"flex justify-center gap-2\">\n              <PreviousButton />\n              <SkipBackwardButton />\n              <PlayPauseButton\n                item={currentQueueItem}\n                variant={playPauseVariant}\n              />\n              <SkipForwardButton />\n              <NextButton />\n              <PlayerVolume />\n            </div>\n          </div>\n        </div>\n      </FramePanel>\n    </Frame>\n  );\n}\n\nexport default function AudioPlayerWidget({\n  className,\n}: {\n  className?: string;\n}) {\n  return (\n    <Player>\n      <Widget className={className} />\n    </Player>\n  );\n}\n",
      "type": "registry:block"
    }
  ],
  "categories": [
    "player"
  ]
}