{
  "name": "shadcn/ui",
  "homepage": "https://ui.shadcn.com",
  "items": [
    {
      "name": "player",
      "type": "registry:component",
      "dependencies": [
        "zustand",
        "lucide-react"
      ],
      "registryDependencies": [
        "@audio/store",
        "@audio/lib",
        "@audio/provider",
        "@audio/slider",
        "@shadcn/empty",
        "@shadcn/button",
        "@shadcn/dialog",
        "@shadcn/dropdown-menu",
        "@shadcn/input",
        "@shadcn/item",
        "@shadcn/scroll-area",
        "@shadcn/toggle",
        "@shadcn/tooltip"
      ],
      "files": [
        {
          "path": "src/registry/default/ui/audio/player.tsx",
          "type": "registry:component",
          "target": "components/audio/player.tsx",
          "content": "\"use client\";\n\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport {\n  FastForwardIcon,\n  Loader2Icon,\n  PauseIcon,\n  PlayIcon,\n  RadioIcon,\n  RewindIcon,\n  SkipBackIcon,\n  SkipForwardIcon,\n  Volume1Icon,\n  Volume2Icon,\n  VolumeIcon,\n  VolumeXIcon,\n} from \"lucide-react\";\nimport React from \"react\";\nimport { formatDuration, isLive } from \"@/lib/audio\";\nimport { useAudioStore } from \"@/lib/audio-store\";\nimport { cn } from \"@/lib/utils\";\nimport { Button, type buttonVariants } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { Slider } from \"@/components/ui/slider\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\n\ninterface AudioPlayerButtonProps extends React.ComponentProps<typeof Button> {\n  tooltip?: boolean;\n  tooltipLabel?: string;\n}\n\nfunction AudioPlayerButton({\n  tooltip = false,\n  tooltipLabel,\n  ...props\n}: AudioPlayerButtonProps) {\n  const button = <Button {...props} />;\n\n  if (tooltip && tooltipLabel) {\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent sideOffset={4}>{tooltipLabel}</TooltipContent>\n      </Tooltip>\n    );\n  }\n\n  return button;\n}\n\nfunction AudioPlayer({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      className={cn(\n        \"w-full rounded-(--radius) border bg-card p-1.5\",\n        className\n      )}\n      data-slot=\"audio-player\"\n      role=\"presentation\"\n      {...props}\n    >\n      {children}\n    </div>\n  );\n}\n\nconst audioControlBarVariants = cva(\n  \"group/audio-control-bar flex w-full min-w-0 items-center gap-1.5\",\n  {\n    variants: {\n      variant: {\n        compact: \"flex-row\",\n        stacked: \"flex-col\",\n      },\n    },\n    defaultVariants: {\n      variant: \"compact\",\n    },\n  }\n);\n\n/**\n * Props for the AudioPlayerControlBar component.\n */\nexport type AudioPlayerControlBarProps = React.ComponentProps<\"div\"> &\n  VariantProps<typeof audioControlBarVariants>;\n\nconst AudioPlayerControlBar = ({\n  className,\n  variant,\n  ...props\n}: AudioPlayerControlBarProps) => (\n  <div\n    className={cn(audioControlBarVariants({ variant }), className)}\n    data-slot=\"audio-control-bar\"\n    data-variant={variant}\n    {...props}\n  />\n);\n\n/**\n * Props for the AudioPlayerControlGroup component.\n */\nexport type AudioPlayerControlGroupProps = React.ComponentProps<\"div\">;\n\nconst AudioPlayerControlGroup = ({\n  className,\n  ...props\n}: AudioPlayerControlGroupProps) => (\n  <div\n    className={cn(\"flex w-full items-center gap-1.5\", className)}\n    data-slot=\"audio-control-group\"\n    {...props}\n  />\n);\n\n/**\n * Props for the AudioPlayerTimeDisplay component.\n */\nexport type AudioPlayerTimeDisplayProps = React.ComponentProps<\"time\"> & {\n  remaining?: boolean;\n};\n\nconst AudioPlayerTimeDisplay = ({\n  className,\n  remaining,\n  ...props\n}: AudioPlayerTimeDisplayProps) => {\n  const { currentTime, duration, currentTrack } = useAudioStore();\n  const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n  const formattedCurrentTime = React.useMemo(\n    () => formatDuration(currentTime),\n    [currentTime]\n  );\n\n  const formattedRemainingTime = React.useMemo(\n    () => formatDuration(duration - currentTime),\n    [duration, currentTime]\n  );\n\n  const timeValue = React.useMemo(() => {\n    if (isLiveStream && remaining) {\n      return \"LIVE\";\n    }\n\n    if (isLiveStream && !remaining) {\n      return formattedCurrentTime;\n    }\n\n    return remaining ? formattedRemainingTime : formattedCurrentTime;\n  }, [isLiveStream, remaining, formattedCurrentTime, formattedRemainingTime]);\n\n  const showLiveIcon = isLiveStream && remaining;\n\n  return (\n    <time\n      className={cn(\n        \"min-w-12 shrink-0 px-1.5 text-left font-mono text-sm tabular-nums\",\n        remaining && \"text-right\",\n        showLiveIcon && \"flex items-center gap-1 text-red-500 text-xs\",\n        className\n      )}\n      data-live={isLiveStream ? \"true\" : undefined}\n      data-remaining={remaining ? \"true\" : undefined}\n      data-slot=\"audio-time-display\"\n      {...props}\n    >\n      {showLiveIcon && <RadioIcon className=\"size-3 animate-pulse\" />}\n      {timeValue}\n    </time>\n  );\n};\n\nconst AudioPlayerSeekBar = ({\n  className,\n  ...props\n}: Omit<\n  React.ComponentProps<typeof Slider>,\n  \"value\" | \"onValueChange\" | \"min\" | \"max\" | \"bufferValue\"\n>) => {\n  const { currentTime, duration, seek, bufferedTime, currentTrack } =\n    useAudioStore();\n  const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n  const progress = React.useMemo(() => {\n    if (isLiveStream) {\n      return 100;\n    }\n    if (!duration) {\n      return 0;\n    }\n    return (currentTime / duration) * 100;\n  }, [isLiveStream, currentTime, duration]);\n\n  const bufferedProgress = React.useMemo(() => {\n    if (isLiveStream) {\n      return 100;\n    }\n    if (!duration) {\n      return 0;\n    }\n    return (bufferedTime / duration) * 100;\n  }, [isLiveStream, bufferedTime, duration]);\n\n  const handleSeek = (e: React.MouseEvent | React.TouchEvent) => {\n    if (isLiveStream || !duration) {\n      return;\n    }\n\n    const target = e.currentTarget;\n    let clientX: number;\n\n    if (\"touches\" in e) {\n      clientX = e.touches[0]?.clientX ?? 0;\n    } else {\n      clientX = e.clientX;\n    }\n\n    const rect = target.getBoundingClientRect();\n    const position = Math.max(\n      0,\n      Math.min(1, (clientX - rect.left) / rect.width)\n    );\n    seek(position * duration);\n  };\n\n  const handleTouchStart = (e: React.TouchEvent) => {\n    if (!isLiveStream) {\n      handleSeek(e);\n    }\n  };\n\n  const handleTouchMove = (e: React.TouchEvent) => {\n    if (!isLiveStream) {\n      e.preventDefault();\n      handleSeek(e);\n    }\n  };\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    if (!isLiveStream && e.buttons === 1) {\n      handleSeek(e);\n    }\n  };\n\n  return (\n    <Slider\n      bufferValue={bufferedProgress}\n      className={cn(\"min-w-20 flex-1\", className)}\n      disabled={isLiveStream}\n      max={100}\n      min={0}\n      onMouseMove={handleMouseMove}\n      onTouchMove={handleTouchMove}\n      onTouchStart={handleTouchStart}\n      onValueChange={(value) => {\n        if (!isLiveStream && value?.[0] !== undefined && duration > 0) {\n          const newTime = (value[0] / 100) * duration;\n          seek(newTime);\n        }\n      }}\n      value={[progress]}\n      {...props}\n    />\n  );\n};\n\nconst AudioPlayerVolume = ({\n  className,\n  size = \"icon\",\n  variant = \"outline\",\n  ...props\n}: Omit<\n  React.ComponentProps<typeof Slider>,\n  \"value\" | \"onValueChange\" | \"min\" | \"max\"\n> & {\n  size?: VariantProps<typeof buttonVariants>[\"size\"];\n  variant?: VariantProps<typeof buttonVariants>[\"variant\"];\n}) => {\n  const volume = useAudioStore((state) => state.volume);\n  const isMuted = useAudioStore((state) => state.isMuted);\n  const setVolume = useAudioStore((state) => state.setVolume);\n  const toggleMute = useAudioStore((state) => state.toggleMute);\n\n  const volumePercent = Math.round(volume * 100);\n\n  const getVolumeIcon = () => {\n    if (isMuted || volume === 0) {\n      return VolumeXIcon;\n    }\n    if (volumePercent < 33) {\n      return VolumeIcon;\n    }\n    if (volumePercent < 66) {\n      return Volume1Icon;\n    }\n    return Volume2Icon;\n  };\n\n  const Icon = getVolumeIcon();\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <AudioPlayerButton\n          className={cn(\"hidden md:flex\", className)}\n          data-slot=\"audio-volume-button\"\n          size={size}\n          tooltip\n          tooltipLabel={\n            isMuted ? \"Muted\" : `Volume ${Math.round(volumePercent)}%`\n          }\n          variant={variant}\n        >\n          <Icon className={cn(isMuted && \"opacity-40\", \"text-primary\")} />\n        </AudioPlayerButton>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent\n        className={cn(\"flex w-48 flex-col gap-1.5 p-1.5\", className)}\n      >\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-sm\">Volume</span>\n          <span className=\"font-mono text-sm tabular-nums\">\n            {volumePercent}%\n          </span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <VolumeXIcon\n            aria-hidden=\"true\"\n            className={cn(\n              \"size-4 shrink-0 cursor-pointer\",\n              isMuted ? \"opacity-40\" : \"opacity-60\"\n            )}\n            onClick={toggleMute}\n            role=\"button\"\n          />\n          <Slider\n            className={cn(className)}\n            max={100}\n            min={0}\n            onValueChange={(value) => {\n              if (value?.[0] !== undefined) {\n                setVolume(value[0] / 100);\n                if (value[0] === 0) {\n                  toggleMute();\n                } else if (isMuted) {\n                  toggleMute();\n                }\n              }\n            }}\n            value={[volumePercent]}\n            {...props}\n          />\n          <Volume2Icon\n            aria-hidden=\"true\"\n            className=\"size-4 shrink-0 opacity-60\"\n          />\n        </div>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n};\n\nconst AudioPlayerPlay = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const isPlaying = useAudioStore((state) => state.isPlaying);\n    const isLoading = useAudioStore((state) => state.isLoading);\n    const isBuffering = useAudioStore((state) => state.isBuffering);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n\n    const togglePlay = useAudioStore((state) => state.togglePlay);\n\n    const handleKeyPress = React.useCallback(\n      (event: KeyboardEvent) => {\n        if (event.code === \"Space\" && event.target === document.body) {\n          event.preventDefault();\n          togglePlay();\n        }\n      },\n      [togglePlay]\n    );\n\n    React.useEffect(() => {\n      document.addEventListener(\"keydown\", handleKeyPress);\n      return () => document.removeEventListener(\"keydown\", handleKeyPress);\n    }, [handleKeyPress]);\n\n    const showSpinner = isLoading || isBuffering;\n\n    const handleClick = React.useCallback(\n      (e: React.MouseEvent<HTMLButtonElement>) => {\n        onClick?.(e);\n        togglePlay();\n      },\n      [onClick, togglePlay]\n    );\n\n    return (\n      <AudioPlayerButton\n        aria-label={isPlaying ? \"Pause\" : \"Play\"}\n        className={cn(className)}\n        data-slot=\"audio-play-button\"\n        disabled={showSpinner || !currentTrack}\n        onClick={handleClick}\n        size={size}\n        tooltip\n        tooltipLabel={isPlaying ? \"Pause\" : \"Play\"}\n        variant={variant}\n        {...props}\n      >\n        {showSpinner && <Loader2Icon className=\"animate-spin\" />}\n        {!showSpinner && isPlaying && <PauseIcon fill=\"currentColor\" />}\n        {!(showSpinner || isPlaying) && <PlayIcon fill=\"currentColor\" />}\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerRewind = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const currentTime = useAudioStore((state) => state.currentTime);\n    const seek = useAudioStore((state) => state.seek);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n    const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n    const seekBackward = React.useCallback(\n      (seconds = 10) => {\n        const newTime = Math.max(currentTime - seconds, 0);\n        seek(newTime);\n      },\n      [currentTime, seek]\n    );\n\n    const disableSeekBackward = React.useMemo(\n      () => !currentTrack || currentTime <= 0 || isLiveStream,\n      [currentTrack, currentTime, isLiveStream]\n    );\n\n    return (\n      <AudioPlayerButton\n        className={cn(className)}\n        data-slot=\"audio-rewind-button\"\n        disabled={disableSeekBackward}\n        onClick={(e) => {\n          onClick?.(e);\n          if (!isLiveStream) {\n            seekBackward(10);\n          }\n        }}\n        size={size}\n        tooltip\n        tooltipLabel={\n          isLiveStream ? \"Not available for live streams\" : \"Skip backward\"\n        }\n        variant={variant}\n        {...props}\n      >\n        <RewindIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerFastForward = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const currentTime = useAudioStore((state) => state.currentTime);\n    const seek = useAudioStore((state) => state.seek);\n    const duration = useAudioStore((state) => state.duration);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n    const isLiveStream = currentTrack ? isLive(currentTrack) : false;\n\n    const seekForward = React.useCallback(\n      (seconds = 10) => {\n        const newTime = Math.min(currentTime + seconds, duration);\n        seek(newTime);\n      },\n      [duration, seek, currentTime]\n    );\n\n    const disableSeekForward = React.useMemo(() => {\n      if (!currentTrack || isLiveStream) {\n        return true;\n      }\n      return duration > 0 && currentTime >= duration;\n    }, [currentTrack, currentTime, duration, isLiveStream]);\n\n    return (\n      <AudioPlayerButton\n        className={cn(className)}\n        data-slot=\"audio-fast-forward-button\"\n        disabled={disableSeekForward}\n        onClick={(e) => {\n          onClick?.(e);\n          if (!isLiveStream) {\n            seekForward(10);\n          }\n        }}\n        size={size}\n        tooltip\n        tooltipLabel={\n          isLiveStream ? \"Not available for live streams\" : \"Skip forward\"\n        }\n        variant={variant}\n        {...props}\n      >\n        <FastForwardIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerSkipForward = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const repeatMode = useAudioStore((state) => state.repeatMode);\n    const queueLength = useAudioStore((state) => state.queue.length);\n    const currentQueueIndex = useAudioStore((state) => state.currentQueueIndex);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n\n    const next = useAudioStore((state) => state.next);\n\n    const disableNext = React.useMemo(\n      () =>\n        !currentTrack ||\n        (currentQueueIndex === queueLength - 1 && repeatMode !== \"all\"),\n      [currentTrack, currentQueueIndex, queueLength, repeatMode]\n    );\n\n    return (\n      <AudioPlayerButton\n        aria-label=\"Next\"\n        className={cn(className)}\n        data-slot=\"audio-skip-forward-button\"\n        disabled={disableNext}\n        onClick={next}\n        size={size}\n        tooltip\n        tooltipLabel=\"Next\"\n        variant={variant}\n        {...props}\n      >\n        <SkipForwardIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nconst AudioPlayerSkipBack = React.memo(\n  ({\n    className,\n    onClick,\n    size = \"icon\",\n    variant = \"ghost\",\n    ...props\n  }: React.ComponentProps<typeof AudioPlayerButton>) => {\n    const repeatMode = useAudioStore((state) => state.repeatMode);\n    const currentQueueIndex = useAudioStore((state) => state.currentQueueIndex);\n    const currentTrack = useAudioStore((state) => state.currentTrack);\n\n    const previous = useAudioStore((state) => state.previous);\n\n    const disablePrevious = React.useMemo(\n      () => !currentTrack || (currentQueueIndex === 0 && repeatMode !== \"all\"),\n      [currentTrack, currentQueueIndex, repeatMode]\n    );\n\n    return (\n      <AudioPlayerButton\n        className={cn(className)}\n        data-slot=\"audio-skip-back-button\"\n        disabled={disablePrevious}\n        onClick={previous}\n        size={size}\n        tooltip\n        tooltipLabel=\"Previous\"\n        variant={variant}\n        {...props}\n      >\n        <SkipBackIcon fill=\"currentColor\" />\n      </AudioPlayerButton>\n    );\n  }\n);\n\nexport {\n  AudioPlayerButton,\n  AudioPlayerControlBar,\n  AudioPlayerControlGroup,\n  AudioPlayerFastForward,\n  AudioPlayerPlay,\n  AudioPlayerRewind,\n  AudioPlayerSeekBar,\n  AudioPlayerSkipBack,\n  AudioPlayerSkipForward,\n  AudioPlayerTimeDisplay,\n  AudioPlayerVolume,\n  AudioPlayer,\n};\n"
        }
      ]
    },
    {
      "name": "provider",
      "type": "registry:component",
      "dependencies": [
        "zustand"
      ],
      "registryDependencies": [
        "@audio/store",
        "@audio/lib"
      ],
      "files": [
        {
          "path": "src/registry/default/ui/audio/provider.tsx",
          "type": "registry:component",
          "target": "components/audio/provider.tsx",
          "content": "\"use client\";\n\nimport React from \"react\";\nimport { $audio, isLive, type Track } from \"@/lib/audio\";\nimport {\n  type AudioStore,\n  calculateNextIndex,\n  canUseDOM,\n  useAudioStore,\n} from \"@/lib/audio-store\";\n\nconst MAX_ERROR_RETRIES = 3;\nconst ERROR_RETRY_DELAY = 1000;\n\nfunction AudioProvider({\n  tracks = [],\n  children,\n}: {\n  tracks?: Track[];\n  children: React.ReactNode;\n}) {\n  const preloadAudioRef = React.useRef<HTMLAudioElement | null>(null);\n  const errorRetryCountRef = React.useRef<number>(0);\n  const throttleInterval = 100;\n  const minUpdateThreshold = 0.5;\n\n  const setState = React.useCallback(\n    (\n      partial:\n        | Partial<AudioStore>\n        | ((state: AudioStore) => Partial<AudioStore>)\n    ) => {\n      useAudioStore.setState(partial);\n    },\n    []\n  );\n\n  React.useEffect(() => {\n    if (tracks && tracks.length > 0) {\n      const state = useAudioStore.getState();\n      const currentQueue = state.queue;\n      const tracksChanged =\n        currentQueue.length === 0 ||\n        currentQueue.length !== tracks.length ||\n        currentQueue.some((track, index) => track.id !== tracks[index]?.id);\n\n      if (tracksChanged) {\n        const firstTrack = tracks[0];\n        useAudioStore.setState({\n          queue: tracks,\n          currentTrack: state.currentTrack || firstTrack,\n          currentQueueIndex:\n            state.currentQueueIndex === -1 ? 0 : state.currentQueueIndex,\n        });\n      }\n    }\n  }, [tracks]);\n\n  const retryPlayback = React.useCallback(async (audio: HTMLAudioElement) => {\n    if (errorRetryCountRef.current >= MAX_ERROR_RETRIES) {\n      return false;\n    }\n\n    errorRetryCountRef.current += 1;\n\n    const delay = 2 ** (errorRetryCountRef.current - 1) * ERROR_RETRY_DELAY;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n\n    if (typeof navigator !== \"undefined\" && !navigator.onLine) {\n      console.warn(\"Offline, delaying retry attempt further.\");\n      return false;\n    }\n\n    try {\n      console.log(\n        `Retry attempt ${errorRetryCountRef.current}: Loading audio...`\n      );\n      const currentTime = audio.currentTime;\n      const wasPlaying = !audio.paused;\n      const state = useAudioStore.getState();\n      if (state.currentTrack) {\n        await $audio.load(state.currentTrack.url, currentTime);\n        if (wasPlaying) {\n          await $audio.play();\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Retry attempt failed:\", error);\n      return false;\n    }\n  }, []);\n\n  const lastUpdateTimeRef = React.useRef<number>(0);\n  const throttledTimeUpdate = React.useCallback(() => {\n    const now = Date.now();\n    if (now - lastUpdateTimeRef.current < throttleInterval) {\n      return;\n    }\n    lastUpdateTimeRef.current = now;\n\n    const audio = $audio.getAudioElement();\n    if (!audio) {\n      return;\n    }\n\n    const currentTime = audio.currentTime;\n    const state = useAudioStore.getState();\n\n    if (Math.abs(state.currentTime - currentTime) > minUpdateThreshold) {\n      const duration = audio.duration;\n      const newProgress = duration > 0 ? (currentTime / duration) * 100 : 0;\n      useAudioStore.setState({ currentTime, progress: newProgress });\n    }\n  }, []);\n\n  const preloadTrack = React.useCallback((song: Track) => {\n    if (!preloadAudioRef.current || preloadAudioRef.current.src === song.url) {\n      return;\n    }\n\n    try {\n      preloadAudioRef.current.src = song.url;\n      preloadAudioRef.current.preload = \"auto\";\n      preloadAudioRef.current.load();\n    } catch (error) {\n      console.error(\"Failed to preload next track:\", error);\n      if (preloadAudioRef.current) {\n        preloadAudioRef.current.src = \"\";\n      }\n    }\n  }, []);\n\n  const preloadNextTrack = React.useCallback(() => {\n    if (!preloadAudioRef.current) {\n      return;\n    }\n\n    const state = useAudioStore.getState();\n    const nextIndex = calculateNextIndex(\n      state.queue,\n      state.currentQueueIndex,\n      state.shuffleEnabled,\n      state.repeatMode\n    );\n\n    if (nextIndex === -1 || nextIndex >= state.queue.length) {\n      return;\n    }\n\n    const nextSong = state.queue[nextIndex];\n    if (!nextSong || nextSong.id === state.currentTrack?.id) {\n      return;\n    }\n\n    preloadTrack(nextSong);\n  }, [preloadTrack]);\n\n  React.useEffect(() => {\n    if (!canUseDOM()) {\n      return;\n    }\n\n    $audio.init();\n\n    preloadAudioRef.current = new Audio();\n    preloadAudioRef.current.muted = true;\n    preloadAudioRef.current.preload = \"none\";\n\n    const audio = $audio.getAudioElement();\n    if (!audio) {\n      console.error(\"Audio element initialization failed\");\n      return;\n    }\n\n    const handlePlay = () => {\n      errorRetryCountRef.current = 0;\n      setState({ isPlaying: true, isLoading: false, isBuffering: false });\n      preloadNextTrack();\n    };\n\n    const handlePause = () => {\n      setState({ isPlaying: false, isBuffering: false });\n    };\n\n    const getErrorInfo = (\n      errorCode: number\n    ): { message: string; recoverable: boolean } => {\n      switch (errorCode) {\n        case MediaError.MEDIA_ERR_ABORTED:\n          return { message: \"Playback cancelled\", recoverable: true };\n        case MediaError.MEDIA_ERR_NETWORK:\n          return { message: \"Network error\", recoverable: true };\n        case MediaError.MEDIA_ERR_DECODE:\n          return {\n            message: \"Audio file decoding error\",\n            recoverable: false,\n          };\n        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:\n          return {\n            message: \"File/network loading error (Code 4)\",\n            recoverable: true,\n          };\n        default:\n          return {\n            message: `Unknown error (${errorCode})`,\n            recoverable: true,\n          };\n      }\n    };\n\n    const parseError = (\n      e: Event\n    ): { message: string; recoverable: boolean; errorCode: number } => {\n      if (audio.error) {\n        const errorCode = audio.error.code;\n        const errorInfo = getErrorInfo(errorCode);\n        return { ...errorInfo, errorCode };\n      }\n\n      if (e instanceof ErrorEvent) {\n        return { message: e.message, recoverable: true, errorCode: 0 };\n      }\n\n      return {\n        message: \"Unknown audio error\",\n        recoverable: false,\n        errorCode: 0,\n      };\n    };\n\n    const handleErrorRetry = async (\n      audioElement: HTMLAudioElement,\n      recoverable: boolean\n    ): Promise<boolean> => {\n      if (!recoverable || errorRetryCountRef.current >= MAX_ERROR_RETRIES) {\n        return false;\n      }\n\n      return await retryPlayback(audioElement);\n    };\n\n    const handleError = async (e: Event) => {\n      const { message: initialMessage, recoverable, errorCode } = parseError(e);\n\n      console.error(\"Audio error details:\", {\n        event: e,\n        audioError: audio.error,\n        message: initialMessage,\n        recoverable,\n        code: errorCode,\n        src: audio.src,\n        readyState: audio.readyState,\n        networkState: audio.networkState,\n      });\n\n      if (await handleErrorRetry(audio, recoverable)) {\n        return;\n      }\n\n      const finalMessage =\n        recoverable && errorRetryCountRef.current >= MAX_ERROR_RETRIES\n          ? `Failed after ${MAX_ERROR_RETRIES} attempts: ${initialMessage}`\n          : initialMessage;\n\n      setState({\n        isPlaying: false,\n        isLoading: false,\n        isBuffering: false,\n        isError: true,\n        errorMessage: finalMessage,\n      });\n    };\n\n    const handleEnded = async () => {\n      setState({ isPlaying: false, isBuffering: false });\n\n      const state = useAudioStore.getState();\n\n      if (state.currentTrack && isLive(state.currentTrack)) {\n        console.warn(\"Live stream ended unexpectedly\");\n        setState({\n          isError: true,\n          errorMessage: \"Live stream connection lost\",\n        });\n        return;\n      }\n      if (state.repeatMode === \"one\" && state.currentTrack) {\n        try {\n          const isLiveStream = isLive(state.currentTrack);\n          await $audio.load(state.currentTrack.url, 0, isLiveStream);\n          await $audio.play();\n          setState({ currentTime: 0, progress: 0 });\n          return;\n        } catch (error) {\n          console.error(\"Repeat mode playback error:\", error);\n        }\n      }\n\n      state.handleTrackEnd();\n    };\n\n    const handleLoadStart = () => {\n      setState({\n        isLoading: true,\n        isBuffering: false,\n        isError: false,\n        errorMessage: null,\n      });\n    };\n\n    const handleCanPlay = () => {\n      const duration = audio.duration || 0;\n      setState({\n        isLoading: false,\n        isBuffering: false,\n        duration,\n        isError: false,\n        errorMessage: null,\n      });\n    };\n\n    const handleWaiting = () => {\n      setState({ isBuffering: true, isLoading: false });\n    };\n\n    const handlePlaying = () => {\n      setState({\n        isLoading: false,\n        isBuffering: false,\n        isPlaying: true,\n        isError: false,\n        errorMessage: null,\n      });\n    };\n\n    const handleDurationChange = () => {\n      const duration = audio.duration || 0;\n      setState({ duration });\n    };\n\n    const handleVolumeChange = () => {\n      setState({ volume: audio.volume, isMuted: audio.muted });\n    };\n\n    const handleBufferUpdate = (e: Event) => {\n      if (e instanceof CustomEvent && e.detail?.bufferedTime !== undefined) {\n        setState({ bufferedTime: e.detail.bufferedTime });\n      }\n    };\n\n    const restoreState = async () => {\n      const state = useAudioStore.getState();\n\n      if (!state.currentTrack || state.currentTime <= 0) {\n        return;\n      }\n\n      const track = state.currentTrack;\n      const isLiveStream = isLive(track);\n      const startTime = isLiveStream ? 0 : state.currentTime;\n      const volume = state.volume;\n      const muted = state.isMuted;\n\n      try {\n        setState({ isLoading: true });\n\n        await $audio.load(track.url, startTime, isLiveStream);\n        $audio.setVolume(volume);\n        $audio.setMuted(muted);\n\n        setState({ isLoading: false, isPlaying: false });\n      } catch (error) {\n        console.error(\"State restoration error:\", error);\n        setState({\n          isError: true,\n          errorMessage: \"Error restoring audio state\",\n          isPlaying: false,\n          isLoading: false,\n          isBuffering: false,\n        });\n      }\n    };\n\n    audio.addEventListener(\"play\", handlePlay);\n    audio.addEventListener(\"pause\", handlePause);\n    audio.addEventListener(\"playing\", handlePlaying);\n    audio.addEventListener(\"waiting\", handleWaiting);\n    audio.addEventListener(\"loadstart\", handleLoadStart);\n    audio.addEventListener(\"canplay\", handleCanPlay);\n    audio.addEventListener(\"canplaythrough\", handleCanPlay);\n    audio.addEventListener(\"timeupdate\", throttledTimeUpdate);\n    audio.addEventListener(\"durationchange\", handleDurationChange);\n    audio.addEventListener(\"loadedmetadata\", handleDurationChange);\n    audio.addEventListener(\"volumechange\", handleVolumeChange);\n    audio.addEventListener(\"ended\", handleEnded);\n    audio.addEventListener(\"error\", handleError);\n\n    $audio.addEventListener(\"bufferUpdate\", handleBufferUpdate);\n\n    restoreState();\n\n    const unsubscribe = useAudioStore.subscribe(\n      (state) => state.currentTrack?.id,\n      (newSongId, oldSongId) => {\n        if (newSongId && newSongId !== oldSongId) {\n          errorRetryCountRef.current = 0;\n          preloadNextTrack();\n        }\n      }\n    );\n\n    return () => {\n      audio.removeEventListener(\"play\", handlePlay);\n      audio.removeEventListener(\"pause\", handlePause);\n      audio.removeEventListener(\"playing\", handlePlaying);\n      audio.removeEventListener(\"waiting\", handleWaiting);\n      audio.removeEventListener(\"loadstart\", handleLoadStart);\n      audio.removeEventListener(\"canplay\", handleCanPlay);\n      audio.removeEventListener(\"canplaythrough\", handleCanPlay);\n      audio.removeEventListener(\"timeupdate\", throttledTimeUpdate);\n      audio.removeEventListener(\"durationchange\", handleDurationChange);\n      audio.removeEventListener(\"loadedmetadata\", handleDurationChange);\n      audio.removeEventListener(\"volumechange\", handleVolumeChange);\n      audio.removeEventListener(\"ended\", handleEnded);\n      audio.removeEventListener(\"error\", handleError);\n\n      $audio.removeEventListener(\"bufferUpdate\", handleBufferUpdate);\n\n      if (preloadAudioRef.current) {\n        preloadAudioRef.current.src = \"\";\n        preloadAudioRef.current = null;\n      }\n\n      unsubscribe();\n    };\n  }, [throttledTimeUpdate, setState, retryPlayback, preloadNextTrack]);\n\n  React.useEffect(() => {\n    const unsubscribe = useAudioStore.subscribe(\n      (state) => state.queue,\n      (newQueue, oldQueue) => {\n        if (\n          (newQueue.length !== oldQueue.length || newQueue.length === 0) &&\n          preloadAudioRef.current\n        ) {\n          preloadAudioRef.current.src = \"\";\n        }\n      }\n    );\n    return unsubscribe;\n  }, []);\n\n  return children;\n}\nconst demoTracks: Track[] = [\n  {\n    id: \"1\",\n    title: \"Beautiful Loop\",\n    artist: \"Flavio Concini\",\n    album: \"Pixabay Music\",\n    url: \"https://cdn.pixabay.com/audio/2024/10/21/audio_78251ef8e3.mp3\",\n    genre: \"Upbeat\",\n  },\n  {\n    id: \"2\",\n    title: \"Type\",\n    artist: \"Aliabbas Abasov\",\n    album: \"Pixabay Music\",\n    url: \"https://cdn.pixabay.com/audio/2024/02/28/audio_60f7a54400.mp3\",\n    genre: \"Hip Hop\",\n  },\n  {\n    id: \"3\",\n    title: \"Radio Tuxnet\",\n    artist: \"Tuxnet\",\n    url: \"/radio/live.aac?host=ice2.tuxnet.me\",\n    genre: \"Hip Hop\",\n    artwork: \"/icon\",\n  },\n  {\n    id: \"4\",\n    title: \"Live Radio\",\n    artist: \"Audio UI\",\n    url: \"https://radio.sevalla.app/live.aac\",\n    artwork: \"/icon\",\n    genre: \"Hip Hop\",\n  },\n];\nexport { AudioProvider, demoTracks };\n"
        }
      ]
    },
    {
      "name": "queue",
      "type": "registry:component",
      "dependencies": [
        "zustand",
        "lucide-react"
      ],
      "registryDependencies": [
        "@audio/store",
        "@audio/lib",
        "@audio/track",
        "@audio/provider",
        "@shadcn/empty",
        "@shadcn/button",
        "@shadcn/command",
        "@shadcn/dialog",
        "@shadcn/dropdown-menu",
        "@shadcn/input",
        "@shadcn/item",
        "@shadcn/scroll-area",
        "@shadcn/toggle",
        "@shadcn/tooltip"
      ],
      "files": [
        {
          "path": "src/registry/default/ui/audio/queue.tsx",
          "type": "registry:component",
          "target": "components/audio/queue.tsx",
          "content": "\"use client\";\n\nimport {\n  ListMusicIcon,\n  Repeat1Icon,\n  RepeatIcon,\n  ShuffleIcon,\n  SlidersHorizontalIcon,\n  TrashIcon,\n} from \"lucide-react\";\nimport type { ComponentProps } from \"react\";\nimport React from \"react\";\nimport type { Track } from \"@/lib/audio\";\nimport {\n  type InsertMode,\n  type RepeatMode,\n  useAudioStore,\n} from \"@/lib/audio-store\";\nimport { cn } from \"@/lib/utils\";\nimport { AudioTrackList } from \"@/components/audio/track\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Command,\n  CommandInput,\n  CommandList,\n} from \"@/components/ui/command\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuLabel,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { Toggle } from \"@/components/ui/toggle\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\n\n/**\n * Props for the AudioQueueButton component.\n */\nexport interface AudioQueueButtonProps extends ComponentProps<typeof Button> {\n  tooltip?: boolean;\n  tooltipLabel?: string;\n}\n\nfunction AudioQueueButton({\n  tooltip = false,\n  tooltipLabel,\n  ...props\n}: AudioQueueButtonProps) {\n  if (tooltip && tooltipLabel) {\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>\n          <Button {...props} />\n        </TooltipTrigger>\n        <TooltipContent sideOffset={4}>{tooltipLabel}</TooltipContent>\n      </Tooltip>\n    );\n  }\n\n  return <Button {...props} />;\n}\n\nconst AudioQueueRepeatMode = ({\n  className,\n  ...props\n}: ComponentProps<typeof Toggle>) => {\n  const repeatMode = useAudioStore((state) => state.repeatMode);\n  const changeRepeatMode = useAudioStore((state) => state.changeRepeatMode);\n  const handleRepeat = React.useCallback(() => {\n    changeRepeatMode();\n  }, [changeRepeatMode]);\n\n  const Icon = repeatMode === \"one\" ? Repeat1Icon : RepeatIcon;\n  let repeatTooltip = \"Disable repeat\";\n  if (repeatMode === \"one\") {\n    repeatTooltip = \"Repeat this track\";\n  } else if (repeatMode === \"all\") {\n    repeatTooltip = \"Repeat playlist\";\n  }\n\n  const isPressed = repeatMode !== \"none\";\n\n  const toggle = (\n    <Toggle\n      className={cn(\n        className,\n        isPressed && \"bg-accent! text-accent-foreground!\"\n      )}\n      data-slot=\"audio-queue-repeat-mode\"\n      onPressedChange={handleRepeat}\n      pressed={isPressed}\n      {...props}\n    >\n      <Icon className=\"size-4\" />\n    </Toggle>\n  );\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>{toggle}</TooltipTrigger>\n      <TooltipContent side=\"top\" sideOffset={4}>\n        {repeatTooltip}\n      </TooltipContent>\n    </Tooltip>\n  );\n};\n\nconst AudioQueueShuffle = ({\n  className,\n  ...props\n}: Omit<ComponentProps<typeof Toggle>, \"onPressedChange\">) => {\n  const shuffle = useAudioStore((state) => state.shuffle);\n  const unshuffle = useAudioStore((state) => state.unshuffle);\n  const shuffleEnabled = useAudioStore((state) => state.shuffleEnabled);\n\n  const handleShuffle = React.useCallback(\n    (pressed: boolean) => {\n      if (pressed) {\n        shuffle();\n      } else {\n        unshuffle();\n      }\n    },\n    [shuffle, unshuffle]\n  );\n\n  const toggle = (\n    <Toggle\n      aria-label=\"Shuffle\"\n      className={cn(\n        className,\n        shuffleEnabled && \"bg-accent! text-accent-foreground!\"\n      )}\n      data-slot=\"audio-queue-shuffle\"\n      onPressedChange={handleShuffle}\n      pressed={shuffleEnabled}\n      {...props}\n    >\n      <ShuffleIcon className=\"size-4\" />\n    </Toggle>\n  );\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>{toggle}</TooltipTrigger>\n      <TooltipContent side=\"top\" sideOffset={4}>\n        Shuffle {shuffleEnabled ? \"on\" : \"off\"}\n      </TooltipContent>\n    </Tooltip>\n  );\n};\n\nconst AudioQueuePreferences = ({\n  className,\n  variant = \"outline\",\n  size = \"icon\",\n  tooltip = true,\n  tooltipLabel = \"Queue preferences\",\n  ...props\n}: React.ComponentProps<typeof AudioQueueButton>) => {\n  const repeatMode = useAudioStore((state) => state.repeatMode);\n  const setRepeatMode = useAudioStore((state) => state.setRepeatMode);\n  const insertMode = useAudioStore((state) => state.insertMode);\n  const setInsertMode = useAudioStore((state) => state.setInsertMode);\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <AudioQueueButton\n          className={cn(className)}\n          data-slot=\"audio-queue-preferences-trigger\"\n          size={size}\n          tooltip\n          tooltipLabel={tooltipLabel}\n          variant={variant}\n          {...props}\n        >\n          <SlidersHorizontalIcon className=\"size-4\" />\n        </AudioQueueButton>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent\n        align=\"end\"\n        className={cn(\"w-45\", className)}\n        data-slot=\"audio-queue-preferences-content\"\n      >\n        <DropdownMenuLabel className=\"text-muted-foreground\">\n          Repeat Mode\n        </DropdownMenuLabel>\n        <DropdownMenuRadioGroup\n          onValueChange={(value) => setRepeatMode(value as RepeatMode)}\n          value={repeatMode}\n        >\n          <DropdownMenuRadioItem value=\"none\">None</DropdownMenuRadioItem>\n          <DropdownMenuRadioItem value=\"one\">One</DropdownMenuRadioItem>\n          <DropdownMenuRadioItem value=\"all\">All</DropdownMenuRadioItem>\n        </DropdownMenuRadioGroup>\n\n        <DropdownMenuLabel className=\"text-muted-foreground\">\n          Insert Mode\n        </DropdownMenuLabel>\n\n        <DropdownMenuRadioGroup\n          onValueChange={(value) => setInsertMode(value as InsertMode)}\n          value={insertMode}\n        >\n          <DropdownMenuRadioItem value=\"first\">First</DropdownMenuRadioItem>\n          <DropdownMenuRadioItem value=\"last\">Last</DropdownMenuRadioItem>\n          <DropdownMenuRadioItem value=\"after\">\n            After Current\n          </DropdownMenuRadioItem>\n        </DropdownMenuRadioGroup>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n};\n\n/**\n * Props for the AudioQueue component.\n */\nexport type AudioQueueProps = {\n  onTrackSelect?: (index: number) => void;\n  searchPlaceholder?: string;\n  emptyLabel?: string;\n  emptyDescription?: string;\n};\n\nconst AudioQueue = React.memo(\n  ({\n    onTrackSelect,\n    searchPlaceholder = \"Search for a track...\",\n    emptyLabel = \"No tracks found\",\n    emptyDescription = \"Try searching for a different track\",\n  }: AudioQueueProps) => {\n    const togglePlay = useAudioStore((state) => state.togglePlay);\n    const currentTrackId = useAudioStore((state) => state.currentTrack?.id);\n    const setQueueAndPlay = useAudioStore((state) => state.setQueueAndPlay);\n    const clearQueue = useAudioStore((state) => state.clearQueue);\n    const removeFromQueue = useAudioStore((state) => state.removeFromQueue);\n\n    const [dialogOpen, setDialogOpen] = React.useState(false);\n    const [searchQuery, setSearchQuery] = React.useState(\"\");\n\n    const isFiltered = searchQuery.trim().length > 0;\n\n    const handleTrackSelect = React.useCallback(\n      (index: number) => {\n        const currentQueue = useAudioStore.getState().queue;\n        let filtered = currentQueue;\n\n        if (searchQuery.trim()) {\n          const query = searchQuery.toLowerCase();\n          filtered = currentQueue.filter(\n            (t: Track) =>\n              t.title?.toLowerCase().includes(query) ||\n              t.artist?.toLowerCase().includes(query)\n          );\n        }\n\n        const selectedTrack = filtered[index];\n        if (!selectedTrack) {\n          return;\n        }\n\n        const trackIndex = currentQueue.findIndex(\n          (t) => t.id === selectedTrack.id\n        );\n        if (trackIndex < 0) {\n          return;\n        }\n\n        if (currentTrackId === selectedTrack.id) {\n          togglePlay();\n        } else if (currentQueue.length > 0) {\n          setQueueAndPlay(currentQueue, trackIndex);\n        }\n        onTrackSelect?.(trackIndex);\n        setDialogOpen(false);\n      },\n      [searchQuery, currentTrackId, togglePlay, setQueueAndPlay, onTrackSelect]\n    );\n\n    const handleTrackRemove = React.useCallback(\n      (trackId: string) => {\n        removeFromQueue(trackId);\n      },\n      [removeFromQueue]\n    );\n\n    const handleClearQueue = React.useCallback(() => {\n      clearQueue();\n    }, [clearQueue]);\n\n    return (\n      <Dialog\n        onOpenChange={(isOpen) => {\n          setDialogOpen(isOpen);\n          if (!isOpen) {\n            setSearchQuery(\"\");\n          }\n        }}\n        open={dialogOpen}\n      >\n        <DialogTrigger asChild>\n          <AudioQueueButton\n            size=\"icon\"\n            tooltip\n            tooltipLabel=\"Queue\"\n            variant=\"outline\"\n          >\n            <ListMusicIcon />\n          </AudioQueueButton>\n        </DialogTrigger>\n        <DialogContent\n          aria-label=\"Select a track\"\n          className=\"rounded-xl border-none bg-clip-padding p-2 pb-11 shadow-2xl ring-4 ring-neutral-200/80 dark:bg-neutral-900 dark:ring-neutral-800\"\n          data-slot=\"audio-queue\"\n          showCloseButton={false}\n        >\n          <DialogHeader className=\"sr-only\">\n            <DialogTitle>Audio Queue</DialogTitle>\n            <DialogDescription>\n              Select a track from the queue to play\n            </DialogDescription>\n          </DialogHeader>\n          <Command\n            className=\"rounded-none bg-transparent **:data-[slot=command-input-wrapper]:mb-0 **:data-[slot=command-input-wrapper]:h-9! **:data-[slot=command-input]:h-9! **:data-[slot=command-input-wrapper]:rounded-md **:data-[slot=command-input-wrapper]:border **:data-[slot=command-input-wrapper]:border-input **:data-[slot=command-input-wrapper]:bg-input/50 **:data-[slot=command-input]:py-0\"\n            filter={(value, search, keywords) => {\n              const extendValue = `${value} ${keywords?.join(\" \") || \"\"}`;\n              if (extendValue.toLowerCase().includes(search.toLowerCase())) {\n                return 1;\n              }\n              return 0;\n            }}\n          >\n            <CommandInput\n              onValueChange={setSearchQuery}\n              placeholder={searchPlaceholder}\n              value={searchQuery}\n            />\n            <CommandList className=\"pt-2 pb-1\">\n              <AudioTrackList\n                className=\"mx-0\"\n                emptyDescription={emptyDescription}\n                emptyLabel={emptyLabel}\n                filterQuery={searchQuery}\n                onTrackRemove={handleTrackRemove}\n                onTrackSelect={handleTrackSelect}\n                sortable={!isFiltered}\n              />\n            </CommandList>\n          </Command>\n          <div className=\"absolute inset-x-0 bottom-0 z-20 flex items-center gap-2 rounded-b-xl border-t border-t-neutral-100 bg-neutral-50 p-1 font-medium text-muted-foreground text-xs dark:border-t-neutral-700 dark:bg-neutral-800\">\n            <AudioQueueButton\n              className=\"w-full\"\n              onClick={handleClearQueue}\n              size=\"sm\"\n              title=\"Clear queue\"\n              variant=\"destructive\"\n            >\n              <TrashIcon className=\"size-4\" /> Clear\n            </AudioQueueButton>\n          </div>\n        </DialogContent>\n      </Dialog>\n    );\n  }\n);\nexport {\n  AudioQueue,\n  AudioQueueButton,\n  AudioQueuePreferences,\n  AudioQueueRepeatMode,\n  AudioQueueShuffle,\n};\n"
        }
      ]
    },
    {
      "name": "track",
      "type": "registry:component",
      "dependencies": [
        "lucide-react"
      ],
      "registryDependencies": [
        "@audio/store",
        "@audio/lib",
        "@audio/sortable-list",
        "@audio/provider",
        "@shadcn/badge",
        "@shadcn/empty",
        "@shadcn/avatar",
        "@shadcn/button",
        "@shadcn/item",
        "@shadcn/scroll-area"
      ],
      "files": [
        {
          "path": "src/registry/default/ui/audio/track.tsx",
          "type": "registry:component",
          "target": "components/audio/track.tsx",
          "content": "\"use client\";\n\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport {\n  ListMusicIcon,\n  MusicIcon,\n  PauseIcon,\n  PlayIcon,\n  RadioIcon,\n  XIcon,\n} from \"lucide-react\";\nimport type React from \"react\";\nimport {\n  formatDuration,\n  isLive,\n  type Track,\n} from \"@/lib/audio\";\nimport { useAudioStore } from \"@/lib/audio-store\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  Avatar,\n  AvatarFallback,\n  AvatarImage,\n} from \"@/components/ui/avatar\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Empty,\n  EmptyDescription,\n  EmptyHeader,\n  EmptyMedia,\n  EmptyTitle,\n} from \"@/components/ui/empty\";\nimport {\n  Item,\n  ItemActions,\n  ItemContent,\n  ItemDescription,\n  ItemMedia,\n  ItemTitle,\n} from \"@/components/ui/item\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport {\n  SortableDragHandle,\n  SortableItem,\n  SortableList,\n} from \"@/components/ui/sortable-list\";\n\n/**\n * Props for the AudioTrack component.\n * Supports two modes: store mode (using trackId) or controlled mode (using track).\n */\nexport type AudioTrackProps = {\n  trackId?: string | number;\n  track?: Track;\n  index?: number;\n  onClick?: () => void;\n  onRemove?: (trackId: string) => void;\n  showRemove?: boolean;\n  showPlayPause?: boolean;\n  showDragHandle?: boolean;\n  showCover?: boolean;\n  className?: string;\n} & (\n  | { trackId: string | number; track?: never }\n  | { track: Track; trackId?: never }\n  | { trackId?: never; track?: never }\n);\n\nfunction getPlayPauseTitle(isCurrent: boolean, isPlaying: boolean): string {\n  if (!isCurrent) {\n    return \"Play this track\";\n  }\n  if (isPlaying) {\n    return \"Pause\";\n  }\n  return \"Play\";\n}\n\nfunction renderTrackMedia(\n  showDragHandle: boolean,\n  showCover: boolean,\n  track: Track,\n  index?: number\n) {\n  if (showDragHandle && showCover) {\n    const coverImage = track.artwork || track.images?.[0];\n    return (\n      <div className=\"flex items-center gap-2\">\n        <SortableDragHandle />\n        {coverImage ? (\n          <Avatar className=\"rounded-sm\">\n            <AvatarImage\n              alt={track.title}\n              className=\"object-cover\"\n              src={coverImage}\n            />\n            <AvatarFallback className=\"rounded-sm\">\n              <MusicIcon className=\"size-4 text-muted-foreground\" />\n            </AvatarFallback>\n          </Avatar>\n        ) : (\n          <div className=\"flex size-10 items-center justify-center rounded-sm bg-muted\">\n            <MusicIcon className=\"size-4 text-muted-foreground\" />\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  if (showDragHandle) {\n    return <SortableDragHandle />;\n  }\n\n  if (showCover) {\n    const coverImage = track.artwork || track.images?.[0];\n    if (coverImage) {\n      return (\n        <Avatar className=\"rounded-sm\">\n          <AvatarImage\n            alt={track.title}\n            className=\"object-cover\"\n            src={coverImage}\n          />\n          <AvatarFallback className=\"rounded-sm\">\n            <MusicIcon className=\"size-4 text-muted-foreground\" />\n          </AvatarFallback>\n        </Avatar>\n      );\n    }\n    return (\n      <div className=\"flex size-10 items-center justify-center rounded-sm bg-muted\">\n        <MusicIcon className=\"size-4 text-muted-foreground\" />\n      </div>\n    );\n  }\n\n  const displayIndex = index !== undefined ? index + 1 : \"\";\n  return (\n    <span className=\"text-muted-foreground/60 text-xs\">{displayIndex}</span>\n  );\n}\n\nfunction AudioTrack({\n  trackId,\n  track: externalTrack,\n  index,\n  onClick,\n  onRemove,\n  showRemove = false,\n  showPlayPause = true,\n  showDragHandle = false,\n  showCover = true,\n  className,\n}: AudioTrackProps) {\n  const queue = useAudioStore((state) => state.queue);\n  const currentTrack = useAudioStore((state) => state.currentTrack);\n  const isPlaying = useAudioStore((state) => state.isPlaying);\n  const duration = useAudioStore((state) => state.duration);\n  const togglePlay = useAudioStore((state) => state.togglePlay);\n  const setQueueAndPlay = useAudioStore((state) => state.setQueueAndPlay);\n\n  const track =\n    externalTrack ??\n    (trackId ? queue.find((t) => String(t.id) === String(trackId)) : undefined);\n\n  if (!track) {\n    return null;\n  }\n\n  const isCurrent = currentTrack?.id === track.id;\n  const actualIsPlaying = isPlaying && isCurrent;\n  const isLiveTrack = isLive(track);\n\n  const trackDuration = isCurrent && duration > 0 ? duration : track.duration;\n\n  const handleRemove = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (track.id && onRemove) {\n      onRemove(String(track.id));\n    }\n  };\n\n  const handlePlayPause = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    e.preventDefault();\n\n    if (isCurrent) {\n      togglePlay();\n    } else {\n      const trackIndex = queue.findIndex((t) => t.id === track.id);\n      if (trackIndex >= 0) {\n        setQueueAndPlay(queue, trackIndex);\n      }\n    }\n  };\n\n  return (\n    <Item\n      className={cn(\n        \"w-full cursor-pointer transition-all hover:bg-secondary/50\",\n        isCurrent && \"bg-secondary/80 backdrop-blur-sm\",\n        className\n      )}\n      onClick={(e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        onClick?.();\n      }}\n      size=\"sm\"\n      variant={isCurrent ? \"outline\" : \"default\"}\n    >\n      <ItemMedia>\n        {renderTrackMedia(showDragHandle, showCover, track, index)}\n      </ItemMedia>\n      <ItemContent className=\"min-w-0 flex-1 gap-0 overflow-hidden\">\n        <div className=\"flex items-center gap-1.5\">\n          <ItemTitle className=\"truncate font-medium text-sm\">\n            {track.title}\n          </ItemTitle>\n          {isLiveTrack && (\n            <Badge className=\"bg-destructive/10 px-1 py-0.5 font-medium text-[10px] text-destructive uppercase leading-none\">\n              <RadioIcon className=\"size-2.5\" />\n              Live\n            </Badge>\n          )}\n        </div>\n        <ItemDescription className=\"text-xs\">{track.artist}</ItemDescription>\n      </ItemContent>\n      {!isLiveTrack && trackDuration !== undefined && (\n        <ItemContent className=\"flex-none text-center\">\n          <ItemDescription>{formatDuration(trackDuration)}</ItemDescription>\n        </ItemContent>\n      )}\n      <ItemActions>\n        {showRemove && !isCurrent && onRemove && (\n          <Button\n            onClick={handleRemove}\n            size=\"icon-sm\"\n            title=\"Remove\"\n            variant=\"ghost\"\n          >\n            <XIcon />\n          </Button>\n        )}\n        {showPlayPause && (\n          <Button\n            onClick={handlePlayPause}\n            size=\"icon-sm\"\n            title={getPlayPauseTitle(isCurrent, actualIsPlaying)}\n            variant=\"ghost\"\n          >\n            {actualIsPlaying ? (\n              <PauseIcon className=\"size-4 fill-current\" />\n            ) : (\n              <PlayIcon className=\"size-4 fill-current\" />\n            )}\n          </Button>\n        )}\n      </ItemActions>\n    </Item>\n  );\n}\n\nAudioTrack.displayName = \"AudioTrack\";\n\nconst audioTrackListVariants = cva(\"w-full\", {\n  variants: {\n    variant: {\n      default: \"space-y-2\",\n      grid: \"grid grid-cols-1 gap-2 xl:grid-cols-2\",\n    },\n  },\n  defaultVariants: {\n    variant: \"default\",\n  },\n});\n\n/**\n * Props for the AudioTrackList component.\n * Can operate in store mode (reads from global queue) or controlled mode (uses provided tracks).\n */\nexport type AudioTrackListProps = {\n  tracks?: Track[];\n  onTrackSelect?: (index: number, track?: Track) => void;\n  onTrackRemove?: (trackId: string) => void;\n  sortable?: boolean;\n  showCover?: boolean;\n  emptyLabel?: string;\n  emptyDescription?: string;\n  filterQuery?: string;\n  filterFn?: (track: Track) => boolean;\n  className?: string;\n} & VariantProps<typeof audioTrackListVariants>;\n\nfunction AudioTrackList({\n  tracks: externalTracks,\n  onTrackSelect,\n  onTrackRemove,\n  sortable = false,\n  showCover = true,\n  variant = \"default\",\n  emptyLabel = \"No tracks found\",\n  emptyDescription = \"Try adding some tracks\",\n  filterQuery,\n  filterFn,\n  className,\n}: AudioTrackListProps) {\n  const queue = useAudioStore((state) => state.queue);\n  const currentTrack = useAudioStore((state) => state.currentTrack);\n  const setQueueAndPlay = useAudioStore((state) => state.setQueueAndPlay);\n  const togglePlay = useAudioStore((state) => state.togglePlay);\n  const setQueue = useAudioStore((state) => state.setQueue);\n  const currentQueueIndex = useAudioStore((state) => state.currentQueueIndex);\n\n  let tracks = externalTracks ?? queue;\n\n  if (filterFn) {\n    tracks = tracks.filter(filterFn);\n  } else if (filterQuery?.trim()) {\n    const query = filterQuery.toLowerCase();\n    tracks = tracks.filter(\n      (track: Track) =>\n        track.title?.toLowerCase().includes(query) ||\n        track.artist?.toLowerCase().includes(query)\n    );\n  }\n\n  const isFiltered = (filterQuery?.trim().length ?? 0) > 0 || !!filterFn;\n  const isExternalTracks = !!externalTracks;\n\n  const handleAutoReorder = (reorderedTracks: Track[]) => {\n    if (!(isFiltered || isExternalTracks)) {\n      const newIndex =\n        currentTrack?.id !== undefined\n          ? reorderedTracks.findIndex((t) => t.id === currentTrack.id)\n          : -1;\n\n      let finalIndex = 0;\n      if (newIndex >= 0) {\n        finalIndex = newIndex;\n      } else if (\n        currentQueueIndex >= 0 &&\n        currentQueueIndex < reorderedTracks.length\n      ) {\n        finalIndex = currentQueueIndex;\n      }\n\n      setQueue(reorderedTracks, finalIndex);\n    }\n  };\n\n  if (tracks.length === 0) {\n    return (\n      <Empty className={cn(\"mx-auto size-full border bg-muted/30\", className)}>\n        <EmptyHeader>\n          <EmptyMedia variant=\"icon\">\n            <ListMusicIcon />\n          </EmptyMedia>\n          <EmptyTitle>{emptyLabel}</EmptyTitle>\n          <EmptyDescription className=\"text-xs/relaxed\">\n            {emptyDescription}\n          </EmptyDescription>\n        </EmptyHeader>\n      </Empty>\n    );\n  }\n\n  const renderTrack = (track: Track, index: number, isOverlay = false) => {\n    const handleTrackClick = () => {\n      if (isExternalTracks) {\n        onTrackSelect?.(index, track);\n      } else {\n        const queueIndex = queue.findIndex((t) => t.id === track.id);\n        if (queueIndex >= 0) {\n          if (currentTrack?.id === track.id) {\n            togglePlay();\n          } else {\n            setQueueAndPlay(queue, queueIndex);\n          }\n          const originalTrack = queue[queueIndex];\n          onTrackSelect?.(queueIndex, originalTrack);\n        } else {\n          onTrackSelect?.(index, track);\n        }\n      }\n    };\n\n    if (!track.id) {\n      return null;\n    }\n\n    const showDragHandle = sortable && !isOverlay;\n\n    return (\n      <AudioTrack\n        index={index}\n        key={track.id}\n        onClick={handleTrackClick}\n        onRemove={onTrackRemove}\n        showCover={showCover}\n        showDragHandle={showDragHandle}\n        showRemove={!!onTrackRemove}\n        track={track}\n      />\n    );\n  };\n\n  const content = sortable ? (\n    <SortableList\n      className={\n        variant === \"grid\" ? \"grid grid-cols-1 gap-2 xl:grid-cols-2\" : \"gap-1\"\n      }\n      items={tracks\n        .filter((t) => t.id !== undefined)\n        .map((t) => ({ id: String(t.id) }))}\n      onChange={(reorderedTracks) => {\n        const reorderedTrackIds = reorderedTracks.map((t) => t.id);\n        const reorderedFullTracks = reorderedTrackIds\n          .map((id) => tracks.find((t) => String(t.id) === id))\n          .filter((t): t is Track => t !== undefined);\n        handleAutoReorder(reorderedFullTracks);\n      }}\n      renderItem={(item, index, isOverlay = false) => {\n        const track = tracks.find((t) => String(t.id) === item.id);\n        if (!track?.id) {\n          return null;\n        }\n        const originalIndex = tracks.findIndex((t) => t.id === track.id);\n        const trackIndex = originalIndex >= 0 ? originalIndex : index;\n\n        const trackContent = renderTrack(track, trackIndex, isOverlay);\n\n        return (\n          <SortableItem id={String(track.id)} key={track.id}>\n            {trackContent}\n          </SortableItem>\n        );\n      }}\n    />\n  ) : (\n    <div className={cn(audioTrackListVariants({ variant }))}>\n      {tracks.map((track, index) => renderTrack(track, index))}\n    </div>\n  );\n\n  return (\n    <ScrollArea\n      className={cn(\"w-full scroll-pt-2 scroll-pb-1.5 pt-1\", className)}\n    >\n      {content}\n    </ScrollArea>\n  );\n}\n\nexport { AudioTrack, AudioTrackList };\n"
        }
      ]
    },
    {
      "name": "ui",
      "type": "registry:ui",
      "registryDependencies": [
        "@audio/slider",
        "@audio/sortable-list"
      ],
      "files": []
    },
    {
      "name": "slider",
      "type": "registry:ui",
      "dependencies": [
        "radix-ui"
      ],
      "registryDependencies": [],
      "files": [
        {
          "path": "src/registry/default/ui/slider.tsx",
          "type": "registry:ui",
          "target": "components/ui/slider.tsx",
          "content": "\"use client\";\n\nimport { Slider as SliderPrimitive } from \"radix-ui\";\nimport React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface SliderProps\n  extends React.ComponentProps<typeof SliderPrimitive.Root> {\n  bufferValue?: number;\n}\n\nfunction Slider({\n  className,\n  defaultValue,\n  value,\n  min = 0,\n  max = 100,\n  bufferValue,\n  ...props\n}: SliderProps) {\n  const _values = React.useMemo(() => {\n    if (Array.isArray(value)) {\n      return value;\n    }\n    if (Array.isArray(defaultValue)) {\n      return defaultValue;\n    }\n    return [min, max];\n  }, [value, defaultValue, min, max]);\n\n  return (\n    <SliderPrimitive.Root\n      className={cn(\n        \"relative flex w-full touch-none select-none items-center data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col data-disabled:opacity-50\",\n        className\n      )}\n      data-slot=\"slider\"\n      defaultValue={defaultValue}\n      max={max}\n      min={min}\n      value={value}\n      {...props}\n    >\n      <SliderPrimitive.Track\n        className={cn(\n          \"relative grow overflow-hidden rounded-full bg-muted data-[orientation=horizontal]:h-1.5 data-[orientation=vertical]:h-full data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-1.5\"\n        )}\n        data-slot=\"slider-track\"\n      >\n        <SliderPrimitive.Range\n          className={cn(\n            \"absolute bg-primary data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full\"\n          )}\n          data-slot=\"slider-range\"\n        />\n        {bufferValue !== undefined && (\n          <SliderPrimitive.Range\n            className=\"absolute z-0 bg-primary/40 data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full\"\n            data-slot=\"buffer-indicator\"\n            style={{\n              width: `${bufferValue || 0}%`,\n              transform: `translateX(-${100 - (bufferValue || 0)}%)`,\n            }}\n          />\n        )}\n      </SliderPrimitive.Track>\n      {Array.from({ length: _values.length }, (_, index) => (\n        <SliderPrimitive.Thumb\n          className=\"block size-4 shrink-0 rounded-full border border-primary bg-white shadow-sm ring-ring/50 transition-[color,box-shadow] hover:ring-4 focus-visible:outline-hidden focus-visible:ring-4 disabled:pointer-events-none disabled:opacity-50\"\n          data-slot=\"slider-thumb\"\n          key={String(index)}\n        />\n      ))}\n    </SliderPrimitive.Root>\n  );\n}\nexport { Slider };\n"
        }
      ]
    },
    {
      "name": "sortable-list",
      "type": "registry:ui",
      "dependencies": [
        "@dnd-kit/core",
        "@dnd-kit/sortable",
        "@dnd-kit/utilities",
        "lucide-react"
      ],
      "registryDependencies": [
        "@shadcn/button"
      ],
      "files": [
        {
          "path": "src/registry/default/ui/sortable-list.tsx",
          "type": "registry:ui",
          "target": "components/ui/sortable-list.tsx",
          "content": "import {\n  type Active,\n  DndContext,\n  type DragEndEvent,\n  type DraggableAttributes,\n  type DraggableSyntheticListeners,\n  DragOverlay,\n  type DragStartEvent,\n  type DropAnimation,\n  defaultDropAnimationSideEffects,\n  KeyboardSensor,\n  PointerSensor,\n  type UniqueIdentifier,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\";\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  useSortable,\n} from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { GripVertical } from \"lucide-react\";\nimport React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\n\nconst DRAG_OPACITY = 0.4;\n\ntype SortableBaseItem = {\n  id: UniqueIdentifier;\n};\n\ntype SortableListProps<TItem extends SortableBaseItem> = {\n  items: TItem[];\n  onChange: (items: TItem[]) => void;\n  renderItem: (\n    item: TItem,\n    index: number,\n    isOverlay?: boolean\n  ) => React.ReactNode;\n  className?: string;\n};\n\nconst SortableList = <TItem extends SortableBaseItem>({\n  items,\n  onChange,\n  renderItem,\n  className,\n}: SortableListProps<TItem>) => {\n  const [active, setActive] = React.useState<Active | null>(null);\n  const [mounted, setMounted] = React.useState(false);\n\n  React.useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  const [activeItem, activeIndex] = React.useMemo(() => {\n    if (active === null) {\n      return [null, null];\n    }\n\n    const index = items.findIndex(({ id }) => id === active.id);\n\n    return [items[index], index];\n  }, [active, items]);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  const handleDragStart = ({ active: activeEvent }: DragStartEvent) => {\n    setActive(activeEvent);\n  };\n\n  const handleDragEnd = ({ active: activeEvent, over }: DragEndEvent) => {\n    if (over && activeEvent.id !== over.id) {\n      const activeEventIndex = items.findIndex(\n        ({ id }) => id === activeEvent.id\n      );\n      const overIndex = items.findIndex(({ id }) => id === over.id);\n\n      onChange(arrayMove(items, activeEventIndex, overIndex));\n    }\n\n    setActive(null);\n  };\n\n  const handleDragCancel = () => {\n    setActive(null);\n  };\n\n  return (\n    <DndContext\n      onDragCancel={handleDragCancel}\n      onDragEnd={handleDragEnd}\n      onDragStart={handleDragStart}\n      sensors={sensors}\n    >\n      <SortableContext items={items}>\n        <ul\n          className={cn(\n            \"flex list-inside list-none list-image-none flex-col p-0\",\n            className\n          )}\n          role=\"application\"\n        >\n          {items.map((item, index) => (\n            <React.Fragment key={item.id}>\n              {renderItem(item, index)}\n            </React.Fragment>\n          ))}\n        </ul>\n      </SortableContext>\n      {mounted &&\n        createPortal(\n          <Overlay>\n            {activeItem && activeIndex !== null\n              ? renderItem(activeItem, activeIndex, true)\n              : null}\n          </Overlay>,\n          document.body\n        )}\n    </DndContext>\n  );\n};\n\nconst dropAnimationConfig: DropAnimation = {\n  sideEffects: defaultDropAnimationSideEffects({\n    styles: {\n      active: {\n        opacity: \"0.4\",\n      },\n    },\n  }),\n};\n\nconst Overlay = ({ children }: React.PropsWithChildren) => (\n  <DragOverlay\n    className=\"z-100 overflow-hidden rounded-md shadow-elevation-card-hover [&>li]:border-b-0\"\n    dropAnimation={dropAnimationConfig}\n    style={{\n      cursor: \"grabbing\",\n    }}\n  >\n    {children}\n  </DragOverlay>\n);\n\ntype SortableItemProps<TItem extends SortableBaseItem> =\n  React.PropsWithChildren<{\n    id: TItem[\"id\"];\n    className?: string;\n  }>;\n\ntype SortableItemContextValue = {\n  attributes: DraggableAttributes;\n  listeners: DraggableSyntheticListeners;\n  ref: (node: HTMLElement | null) => void;\n  isDragging: boolean;\n};\n\nconst SortableItemContext =\n  React.createContext<SortableItemContextValue | null>(null);\n\nconst useSortableItemContext = () => {\n  const context = React.useContext(SortableItemContext);\n\n  if (!context) {\n    throw new Error(\n      \"useSortableItemContext must be used within a SortableItemContext\"\n    );\n  }\n\n  return context;\n};\n\nconst SortableItem = <TItem extends SortableBaseItem>({\n  id,\n  className,\n  children,\n}: SortableItemProps<TItem>) => {\n  const {\n    attributes,\n    isDragging,\n    listeners,\n    setNodeRef,\n    setActivatorNodeRef,\n    transform,\n    transition,\n  } = useSortable({ id });\n\n  const context = React.useMemo(\n    () => ({\n      attributes,\n      listeners,\n      ref: setActivatorNodeRef,\n      isDragging,\n    }),\n    [attributes, listeners, setActivatorNodeRef, isDragging]\n  );\n\n  const style: React.CSSProperties = {\n    opacity: isDragging ? DRAG_OPACITY : undefined,\n    transform: CSS.Translate.toString(transform),\n    transition,\n  };\n\n  return (\n    <SortableItemContext.Provider value={context}>\n      <li\n        className={cn(\"flex flex-1 list-none transition-colors\", className)}\n        ref={setNodeRef}\n        style={style}\n      >\n        {children}\n      </li>\n    </SortableItemContext.Provider>\n  );\n};\n\nconst SortableDragHandle = () => {\n  const { attributes, listeners, ref } = useSortableItemContext();\n\n  return (\n    <Button\n      size=\"icon-sm\"\n      variant=\"ghost\"\n      {...attributes}\n      {...listeners}\n      className=\"cursor-grab touch-none active:cursor-grabbing\"\n      ref={ref}\n    >\n      <GripVertical className=\"size-4\" />\n    </Button>\n  );\n};\nexport { SortableList, SortableItem, SortableDragHandle };\n"
        }
      ]
    },
    {
      "name": "player-demo",
      "description": "Audio player demo",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/player-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/player-demo.tsx",
          "content": "import {\n  AudioPlayer,\n  AudioPlayerControlBar,\n  AudioPlayerPlay,\n  AudioPlayerSeekBar,\n  AudioPlayerTimeDisplay,\n  AudioPlayerVolume,\n} from \"@/components/audio/player\";\n\nexport default function AudioDemoPlayer() {\n  return (\n    <AudioPlayer>\n      <AudioPlayerControlBar>\n        <AudioPlayerPlay />\n        <AudioPlayerSeekBar />\n        <AudioPlayerTimeDisplay />\n        <AudioPlayerVolume />\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "player"
      ]
    },
    {
      "name": "player-queue-demo",
      "description": "Audio player with queue demo",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/queue"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/player-queue-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/player-queue-demo.tsx",
          "content": "import {\n  AudioPlayer,\n  AudioPlayerControlBar,\n  AudioPlayerControlGroup,\n  AudioPlayerPlay,\n  AudioPlayerSeekBar,\n  AudioPlayerSkipBack,\n  AudioPlayerSkipForward,\n  AudioPlayerTimeDisplay,\n  AudioPlayerVolume,\n} from \"@/components/audio/player\";\nimport {\n  AudioQueue,\n  AudioQueueRepeatMode,\n  AudioQueueShuffle,\n} from \"@/components/audio/queue\";\n\nexport default function AudioPlayerQueueDemo() {\n  return (\n    <AudioPlayer>\n      <AudioPlayerControlBar variant=\"stacked\">\n        <AudioPlayerControlGroup>\n          <AudioPlayerTimeDisplay />\n          <AudioPlayerSeekBar />\n          <AudioPlayerTimeDisplay remaining />\n        </AudioPlayerControlGroup>\n        <AudioPlayerControlGroup>\n          <AudioPlayerControlGroup>\n            <AudioPlayerSkipBack />\n            <AudioPlayerPlay />\n            <AudioPlayerSkipForward />\n          </AudioPlayerControlGroup>\n          <AudioQueueShuffle />\n          <AudioQueueRepeatMode />\n          <AudioPlayerVolume />\n          <AudioQueue />\n        </AudioPlayerControlGroup>\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "player",
        "queue"
      ]
    },
    {
      "name": "player-stacked-demo",
      "description": "Audio player with stacked layout",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/player-stacked-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/player-stacked-demo.tsx",
          "content": "import {\n  AudioPlayer,\n  AudioPlayerControlBar,\n  AudioPlayerControlGroup,\n  AudioPlayerPlay,\n  AudioPlayerSeekBar,\n  AudioPlayerSkipBack,\n  AudioPlayerSkipForward,\n  AudioPlayerTimeDisplay,\n  AudioPlayerVolume,\n} from \"@/components/audio/player\";\n\nexport default function AudioPlayerStackedDemo() {\n  return (\n    <AudioPlayer>\n      <AudioPlayerControlBar variant=\"stacked\">\n        <AudioPlayerControlGroup>\n          <AudioPlayerTimeDisplay />\n          <AudioPlayerSeekBar />\n          <AudioPlayerTimeDisplay remaining />\n        </AudioPlayerControlGroup>\n        <AudioPlayerControlGroup>\n          <AudioPlayerControlGroup className=\"justify-between md:justify-start\">\n            <AudioPlayerSkipBack />\n            <AudioPlayerPlay />\n            <AudioPlayerSkipForward />\n          </AudioPlayerControlGroup>\n          <AudioPlayerVolume />\n        </AudioPlayerControlGroup>\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "player"
      ]
    },
    {
      "name": "queue-shuffle-repeat-demo",
      "description": "Minimal queue with shuffle and repeat controls",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/queue"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/queue-shuffle-repeat-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/queue-shuffle-repeat-demo.tsx",
          "content": "import {\n  AudioPlayer,\n  AudioPlayerControlBar,\n} from \"@/components/audio/player\";\nimport {\n  AudioQueue,\n  AudioQueueRepeatMode,\n  AudioQueueShuffle,\n} from \"@/components/audio/queue\";\n\nexport default function AudioQueueShuffleRepeatDemo() {\n  return (\n    <AudioPlayer className=\"w-max\">\n      <AudioPlayerControlBar>\n        <AudioQueueShuffle />\n        <AudioQueueRepeatMode />\n        <AudioQueue />\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "queue"
      ]
    },
    {
      "name": "queue-preferences-demo",
      "description": "Minimal queue with preferences dropdown",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/queue"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/queue-preferences-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/queue-preferences-demo.tsx",
          "content": "import {\n  AudioPlayer,\n  AudioPlayerControlBar,\n} from \"@/components/audio/player\";\nimport {\n  AudioQueue,\n  AudioQueuePreferences,\n} from \"@/components/audio/queue\";\n\nexport default function AudioQueuePreferencesDemo() {\n  return (\n    <AudioPlayer className=\"w-max\">\n      <AudioPlayerControlBar>\n        <AudioQueuePreferences />\n        <AudioQueue />\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "queue"
      ]
    },
    {
      "name": "queue-all-controls-demo",
      "description": "Queue with all controls (shuffle, repeat, preferences)",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/queue"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/queue-all-controls-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/queue-all-controls-demo.tsx",
          "content": "import {\n  AudioPlayer,\n  AudioPlayerControlBar,\n} from \"@/components/audio/player\";\nimport {\n  AudioQueue,\n  AudioQueuePreferences,\n  AudioQueueRepeatMode,\n  AudioQueueShuffle,\n} from \"@/components/audio/queue\";\n\nexport default function AudioQueueAllControlsDemo() {\n  return (\n    <AudioPlayer className=\"w-max\">\n      <AudioPlayerControlBar>\n        <AudioQueueShuffle />\n        <AudioQueueRepeatMode />\n        <AudioQueuePreferences />\n        <AudioQueue />\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "queue"
      ]
    },
    {
      "name": "track-demo",
      "description": "Minimal track component example",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/track"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/track-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/track-demo.tsx",
          "content": "\"use client\";\n\nimport { AudioTrack } from \"@/components/audio/track\";\n\nexport default function AudioTrackDemo() {\n  return <AudioTrack className=\"w-full\" trackId={\"4\"} />;\n}\n"
        }
      ],
      "categories": [
        "track"
      ]
    },
    {
      "name": "track-list-demo",
      "description": "Track list with selection example",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/track"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/track-list-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/track-list-demo.tsx",
          "content": "\"use client\";\nimport { toast } from \"sonner\";\nimport { useAudioStore } from \"@/lib/audio-store\";\nimport { AudioTrackList } from \"@/components/audio/track\";\n\nexport default function AudioTrackListDemo() {\n  const queue = useAudioStore((state) => state.queue);\n\n  return (\n    <AudioTrackList\n      className=\"w-full\"\n      onTrackSelect={(index) => {\n        const track = queue[index];\n        toast.info(`Playing: ${track?.title}`);\n      }}\n    />\n  );\n}\n"
        }
      ],
      "categories": [
        "track"
      ]
    },
    {
      "name": "track-list-grid-demo",
      "description": "Track list with grid layout example",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/track"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/track-list-grid-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/track-list-grid-demo.tsx",
          "content": "\"use client\";\nimport { toast } from \"sonner\";\nimport { useAudioStore } from \"@/lib/audio-store\";\nimport { AudioTrackList } from \"@/components/audio/track\";\n\nexport default function AudioTrackListGridDemo() {\n  const queue = useAudioStore((state) => state.queue);\n\n  return (\n    <AudioTrackList\n      className=\"w-full\"\n      onTrackSelect={(index) => {\n        const track = queue[index];\n        toast.info(`Playing: ${track?.title}`);\n      }}\n      variant=\"grid\"\n    />\n  );\n}\n"
        }
      ],
      "categories": [
        "track",
        "grid"
      ]
    },
    {
      "name": "track-sortable-list-demo",
      "description": "Track list with sortable selection example",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/track"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/track-sortable-list-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/track-sortable-list-demo.tsx",
          "content": "\"use client\";\nimport { toast } from \"sonner\";\nimport { useAudioStore } from \"@/lib/audio-store\";\nimport { AudioTrackList } from \"@/components/audio/track\";\n\nexport default function AudioTrackSortableListDemo() {\n  const queue = useAudioStore((state) => state.queue);\n\n  return (\n    <AudioTrackList\n      className=\"w-full\"\n      onTrackSelect={(index) => {\n        const track = queue[index];\n        toast.info(`Playing ${track?.title}`);\n      }}\n      sortable\n    />\n  );\n}\n"
        }
      ],
      "categories": [
        "track",
        "sortable"
      ]
    },
    {
      "name": "track-sortable-list-grid-demo",
      "description": "Track list with sortable selection and grid layout example",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/player",
        "@audio/track"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/track-sortable-list-grid-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/track-sortable-list-grid-demo.tsx",
          "content": "\"use client\";\nimport { toast } from \"sonner\";\nimport { useAudioStore } from \"@/lib/audio-store\";\nimport { AudioTrackList } from \"@/components/audio/track\";\n\nexport default function AudioTrackSortableListGridDemo() {\n  const queue = useAudioStore((state) => state.queue);\n\n  return (\n    <AudioTrackList\n      className=\"w-full\"\n      onTrackSelect={(index) => {\n        const track = queue[index];\n        toast.info(`Playing ${track?.title}`);\n      }}\n      sortable\n      variant=\"grid\"\n    />\n  );\n}\n"
        }
      ],
      "categories": [
        "track",
        "sortable",
        "grid"
      ]
    },
    {
      "name": "slider-demo",
      "description": "Slider component examples",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/slider"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/slider-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/slider-demo.tsx",
          "content": "\"use client\";\n\nimport { useState } from \"react\";\nimport { Slider } from \"@/components/ui/slider\";\n\nexport default function SliderDemo() {\n  const [value, setValue] = useState([50]);\n  const bufferValue = 75;\n\n  return (\n    <div className=\"w-full space-y-8 px-4\">\n      <div className=\"space-y-2\">\n        <h3 className=\"font-medium text-sm\">Basic Slider</h3>\n        <Slider className=\"w-full\" onValueChange={setValue} value={value} />\n        <p className=\"text-muted-foreground text-xs\">Value: {value[0]}</p>\n      </div>\n\n      <div className=\"space-y-2\">\n        <h3 className=\"font-medium text-sm\">Slider with Buffer</h3>\n        <Slider\n          bufferValue={bufferValue}\n          className=\"w-full\"\n          onValueChange={setValue}\n          value={value}\n        />\n        <p className=\"text-muted-foreground text-xs\">\n          Value: {value[0]} | Buffer: {bufferValue}%\n        </p>\n      </div>\n\n      <div className=\"space-y-2\">\n        <h3 className=\"font-medium text-sm\">Range Slider</h3>\n        <Slider\n          className=\"w-full\"\n          defaultValue={[20, 80]}\n          max={100}\n          min={0}\n          step={1}\n        />\n        <p className=\"text-muted-foreground text-xs\">Range: 20 - 80</p>\n      </div>\n\n      <div className=\"space-y-2\">\n        <h3 className=\"font-medium text-sm\">Disabled Slider</h3>\n        <Slider className=\"w-full\" defaultValue={[30]} disabled />\n        <p className=\"text-muted-foreground text-xs\">Disabled state</p>\n      </div>\n    </div>\n  );\n}\n"
        }
      ],
      "categories": [
        "slider",
        "ui"
      ]
    },
    {
      "name": "sortable-list-demo",
      "description": "Sortable list component examples",
      "type": "registry:example",
      "registryDependencies": [
        "@audio/sortable-list"
      ],
      "files": [
        {
          "path": "src/registry/default/examples/sortable-list-demo.tsx",
          "type": "registry:example",
          "target": "components/audio/examples/sortable-list-demo.tsx",
          "content": "\"use client\";\n\nimport { useState } from \"react\";\nimport {\n  SortableDragHandle,\n  SortableItem,\n  SortableList,\n} from \"@/components/ui/sortable-list\";\n\ntype Item = {\n  id: string;\n  title: string;\n  description: string;\n};\n\nconst initialItems: Item[] = [\n  {\n    id: \"1\",\n    title: \"Item 1\",\n    description: \"Description for item 1\",\n  },\n  {\n    id: \"2\",\n    title: \"Item 2\",\n    description: \"Description for item 2\",\n  },\n  {\n    id: \"3\",\n    title: \"Item 3\",\n    description: \"Description for item 3\",\n  },\n  {\n    id: \"4\",\n    title: \"Item 4\",\n    description: \"Description for item 4\",\n  },\n];\n\nexport default function SortableListDemo() {\n  const [items, setItems] = useState<Item[]>(initialItems);\n\n  return (\n    <div className=\"w-full space-y-8 px-4\">\n      <div className=\"space-y-2\">\n        <h3 className=\"font-medium text-sm\">Basic Sortable List</h3>\n        <SortableList\n          items={items}\n          onChange={setItems}\n          renderItem={(item) => (\n            <SortableItem\n              className=\"flex items-center gap-3 rounded-md border border-border bg-card p-3\"\n              id={item.id}\n            >\n              <SortableDragHandle />\n              <div className=\"flex-1\">\n                <p className=\"font-medium text-sm\">{item.title}</p>\n                <p className=\"text-muted-foreground text-xs\">\n                  {item.description}\n                </p>\n              </div>\n            </SortableItem>\n          )}\n        />\n      </div>\n    </div>\n  );\n}\n"
        }
      ],
      "categories": [
        "sortable-list",
        "ui"
      ]
    },
    {
      "name": "theme-stone",
      "type": "registry:theme",
      "cssVars": {
        "light": {
          "background": "oklch(1 0 0)",
          "foreground": "oklch(0.147 0.004 49.25)",
          "card": "oklch(1 0 0)",
          "card-foreground": "oklch(0.147 0.004 49.25)",
          "popover": "oklch(1 0 0)",
          "popover-foreground": "oklch(0.147 0.004 49.25)",
          "primary": "oklch(0.216 0.006 56.043)",
          "primary-foreground": "oklch(0.985 0.001 106.423)",
          "secondary": "oklch(0.97 0.001 106.424)",
          "secondary-foreground": "oklch(0.216 0.006 56.043)",
          "muted": "oklch(0.97 0.001 106.424)",
          "muted-foreground": "oklch(0.553 0.013 58.071)",
          "accent": "oklch(0.97 0.001 106.424)",
          "accent-foreground": "oklch(0.216 0.006 56.043)",
          "destructive": "oklch(0.577 0.245 27.325)",
          "border": "oklch(0.923 0.003 48.717)",
          "input": "oklch(0.923 0.003 48.717)",
          "ring": "oklch(0.709 0.01 56.259)",
          "chart-1": "oklch(0.646 0.222 41.116)",
          "chart-2": "oklch(0.6 0.118 184.704)",
          "chart-3": "oklch(0.398 0.07 227.392)",
          "chart-4": "oklch(0.828 0.189 84.429)",
          "chart-5": "oklch(0.769 0.188 70.08)",
          "radius": "0.625rem",
          "sidebar": "oklch(0.985 0.001 106.423)",
          "sidebar-foreground": "oklch(0.147 0.004 49.25)",
          "sidebar-primary": "oklch(0.216 0.006 56.043)",
          "sidebar-primary-foreground": "oklch(0.985 0.001 106.423)",
          "sidebar-accent": "oklch(0.97 0.001 106.424)",
          "sidebar-accent-foreground": "oklch(0.216 0.006 56.043)",
          "sidebar-border": "oklch(0.923 0.003 48.717)",
          "sidebar-ring": "oklch(0.709 0.01 56.259)"
        },
        "dark": {
          "background": "oklch(0.147 0.004 49.25)",
          "foreground": "oklch(0.985 0.001 106.423)",
          "card": "oklch(0.216 0.006 56.043)",
          "card-foreground": "oklch(0.985 0.001 106.423)",
          "popover": "oklch(0.216 0.006 56.043)",
          "popover-foreground": "oklch(0.985 0.001 106.423)",
          "primary": "oklch(0.923 0.003 48.717)",
          "primary-foreground": "oklch(0.216 0.006 56.043)",
          "secondary": "oklch(0.268 0.007 34.298)",
          "secondary-foreground": "oklch(0.985 0.001 106.423)",
          "muted": "oklch(0.268 0.007 34.298)",
          "muted-foreground": "oklch(0.709 0.01 56.259)",
          "accent": "oklch(0.268 0.007 34.298)",
          "accent-foreground": "oklch(0.985 0.001 106.423)",
          "destructive": "oklch(0.704 0.191 22.216)",
          "border": "oklch(1 0 0 / 10%)",
          "input": "oklch(1 0 0 / 15%)",
          "ring": "oklch(0.553 0.013 58.071)",
          "chart-1": "oklch(0.488 0.243 264.376)",
          "chart-2": "oklch(0.696 0.17 162.48)",
          "chart-3": "oklch(0.769 0.188 70.08)",
          "chart-4": "oklch(0.627 0.265 303.9)",
          "chart-5": "oklch(0.645 0.246 16.439)",
          "sidebar": "oklch(0.216 0.006 56.043)",
          "sidebar-foreground": "oklch(0.985 0.001 106.423)",
          "sidebar-primary": "oklch(0.488 0.243 264.376)",
          "sidebar-primary-foreground": "oklch(0.985 0.001 106.423)",
          "sidebar-accent": "oklch(0.268 0.007 34.298)",
          "sidebar-accent-foreground": "oklch(0.985 0.001 106.423)",
          "sidebar-border": "oklch(1 0 0 / 10%)",
          "sidebar-ring": "oklch(0.553 0.013 58.071)"
        }
      },
      "files": []
    },
    {
      "name": "theme-zinc",
      "type": "registry:theme",
      "cssVars": {
        "light": {
          "background": "oklch(1 0 0)",
          "foreground": "oklch(0.141 0.005 285.823)",
          "card": "oklch(1 0 0)",
          "card-foreground": "oklch(0.141 0.005 285.823)",
          "popover": "oklch(1 0 0)",
          "popover-foreground": "oklch(0.141 0.005 285.823)",
          "primary": "oklch(0.21 0.006 285.885)",
          "primary-foreground": "oklch(0.985 0 0)",
          "secondary": "oklch(0.967 0.001 286.375)",
          "secondary-foreground": "oklch(0.21 0.006 285.885)",
          "muted": "oklch(0.967 0.001 286.375)",
          "muted-foreground": "oklch(0.552 0.016 285.938)",
          "accent": "oklch(0.967 0.001 286.375)",
          "accent-foreground": "oklch(0.21 0.006 285.885)",
          "destructive": "oklch(0.577 0.245 27.325)",
          "border": "oklch(0.92 0.004 286.32)",
          "input": "oklch(0.92 0.004 286.32)",
          "ring": "oklch(0.705 0.015 286.067)",
          "chart-1": "oklch(0.646 0.222 41.116)",
          "chart-2": "oklch(0.6 0.118 184.704)",
          "chart-3": "oklch(0.398 0.07 227.392)",
          "chart-4": "oklch(0.828 0.189 84.429)",
          "chart-5": "oklch(0.769 0.188 70.08)",
          "radius": "0.625rem",
          "sidebar": "oklch(0.985 0 0)",
          "sidebar-foreground": "oklch(0.141 0.005 285.823)",
          "sidebar-primary": "oklch(0.21 0.006 285.885)",
          "sidebar-primary-foreground": "oklch(0.985 0 0)",
          "sidebar-accent": "oklch(0.967 0.001 286.375)",
          "sidebar-accent-foreground": "oklch(0.21 0.006 285.885)",
          "sidebar-border": "oklch(0.92 0.004 286.32)",
          "sidebar-ring": "oklch(0.705 0.015 286.067)"
        },
        "dark": {
          "background": "oklch(0.141 0.005 285.823)",
          "foreground": "oklch(0.985 0 0)",
          "card": "oklch(0.21 0.006 285.885)",
          "card-foreground": "oklch(0.985 0 0)",
          "popover": "oklch(0.21 0.006 285.885)",
          "popover-foreground": "oklch(0.985 0 0)",
          "primary": "oklch(0.92 0.004 286.32)",
          "primary-foreground": "oklch(0.21 0.006 285.885)",
          "secondary": "oklch(0.274 0.006 286.033)",
          "secondary-foreground": "oklch(0.985 0 0)",
          "muted": "oklch(0.274 0.006 286.033)",
          "muted-foreground": "oklch(0.705 0.015 286.067)",
          "accent": "oklch(0.274 0.006 286.033)",
          "accent-foreground": "oklch(0.985 0 0)",
          "destructive": "oklch(0.704 0.191 22.216)",
          "border": "oklch(1 0 0 / 10%)",
          "input": "oklch(1 0 0 / 15%)",
          "ring": "oklch(0.552 0.016 285.938)",
          "chart-1": "oklch(0.488 0.243 264.376)",
          "chart-2": "oklch(0.696 0.17 162.48)",
          "chart-3": "oklch(0.769 0.188 70.08)",
          "chart-4": "oklch(0.627 0.265 303.9)",
          "chart-5": "oklch(0.645 0.246 16.439)",
          "sidebar": "oklch(0.21 0.006 285.885)",
          "sidebar-foreground": "oklch(0.985 0 0)",
          "sidebar-primary": "oklch(0.488 0.243 264.376)",
          "sidebar-primary-foreground": "oklch(0.985 0 0)",
          "sidebar-accent": "oklch(0.274 0.006 286.033)",
          "sidebar-accent-foreground": "oklch(0.985 0 0)",
          "sidebar-border": "oklch(1 0 0 / 10%)",
          "sidebar-ring": "oklch(0.552 0.016 285.938)"
        }
      },
      "files": []
    },
    {
      "name": "theme-neutral",
      "type": "registry:theme",
      "cssVars": {
        "light": {
          "background": "oklch(1 0 0)",
          "foreground": "oklch(0.145 0 0)",
          "card": "oklch(1 0 0)",
          "card-foreground": "oklch(0.145 0 0)",
          "popover": "oklch(1 0 0)",
          "popover-foreground": "oklch(0.145 0 0)",
          "primary": "oklch(0.205 0 0)",
          "primary-foreground": "oklch(0.985 0 0)",
          "secondary": "oklch(0.97 0 0)",
          "secondary-foreground": "oklch(0.205 0 0)",
          "muted": "oklch(0.97 0 0)",
          "muted-foreground": "oklch(0.556 0 0)",
          "accent": "oklch(0.97 0 0)",
          "accent-foreground": "oklch(0.205 0 0)",
          "destructive": "oklch(0.577 0.245 27.325)",
          "border": "oklch(0.922 0 0)",
          "input": "oklch(0.922 0 0)",
          "ring": "oklch(0.708 0 0)",
          "chart-1": "oklch(0.646 0.222 41.116)",
          "chart-2": "oklch(0.6 0.118 184.704)",
          "chart-3": "oklch(0.398 0.07 227.392)",
          "chart-4": "oklch(0.828 0.189 84.429)",
          "chart-5": "oklch(0.769 0.188 70.08)",
          "radius": "0.625rem",
          "sidebar": "oklch(0.985 0 0)",
          "sidebar-foreground": "oklch(0.145 0 0)",
          "sidebar-primary": "oklch(0.205 0 0)",
          "sidebar-primary-foreground": "oklch(0.985 0 0)",
          "sidebar-accent": "oklch(0.97 0 0)",
          "sidebar-accent-foreground": "oklch(0.205 0 0)",
          "sidebar-border": "oklch(0.922 0 0)",
          "sidebar-ring": "oklch(0.708 0 0)"
        },
        "dark": {
          "background": "oklch(0.145 0 0)",
          "foreground": "oklch(0.985 0 0)",
          "card": "oklch(0.205 0 0)",
          "card-foreground": "oklch(0.985 0 0)",
          "popover": "oklch(0.205 0 0)",
          "popover-foreground": "oklch(0.985 0 0)",
          "primary": "oklch(0.922 0 0)",
          "primary-foreground": "oklch(0.205 0 0)",
          "secondary": "oklch(0.269 0 0)",
          "secondary-foreground": "oklch(0.985 0 0)",
          "muted": "oklch(0.269 0 0)",
          "muted-foreground": "oklch(0.708 0 0)",
          "accent": "oklch(0.269 0 0)",
          "accent-foreground": "oklch(0.985 0 0)",
          "destructive": "oklch(0.704 0.191 22.216)",
          "border": "oklch(1 0 0 / 10%)",
          "input": "oklch(1 0 0 / 15%)",
          "ring": "oklch(0.556 0 0)",
          "chart-1": "oklch(0.488 0.243 264.376)",
          "chart-2": "oklch(0.696 0.17 162.48)",
          "chart-3": "oklch(0.769 0.188 70.08)",
          "chart-4": "oklch(0.627 0.265 303.9)",
          "chart-5": "oklch(0.645 0.246 16.439)",
          "sidebar": "oklch(0.205 0 0)",
          "sidebar-foreground": "oklch(0.985 0 0)",
          "sidebar-primary": "oklch(0.488 0.243 264.376)",
          "sidebar-primary-foreground": "oklch(0.985 0 0)",
          "sidebar-accent": "oklch(0.269 0 0)",
          "sidebar-accent-foreground": "oklch(0.985 0 0)",
          "sidebar-border": "oklch(1 0 0 / 10%)",
          "sidebar-ring": "oklch(0.556 0 0)"
        }
      },
      "files": []
    },
    {
      "name": "theme-gray",
      "type": "registry:theme",
      "cssVars": {
        "light": {
          "background": "oklch(1 0 0)",
          "foreground": "oklch(0.13 0.028 261.692)",
          "card": "oklch(1 0 0)",
          "card-foreground": "oklch(0.13 0.028 261.692)",
          "popover": "oklch(1 0 0)",
          "popover-foreground": "oklch(0.13 0.028 261.692)",
          "primary": "oklch(0.21 0.034 264.665)",
          "primary-foreground": "oklch(0.985 0.002 247.839)",
          "secondary": "oklch(0.967 0.003 264.542)",
          "secondary-foreground": "oklch(0.21 0.034 264.665)",
          "muted": "oklch(0.967 0.003 264.542)",
          "muted-foreground": "oklch(0.551 0.027 264.364)",
          "accent": "oklch(0.967 0.003 264.542)",
          "accent-foreground": "oklch(0.21 0.034 264.665)",
          "destructive": "oklch(0.577 0.245 27.325)",
          "border": "oklch(0.928 0.006 264.531)",
          "input": "oklch(0.928 0.006 264.531)",
          "ring": "oklch(0.707 0.022 261.325)",
          "chart-1": "oklch(0.646 0.222 41.116)",
          "chart-2": "oklch(0.6 0.118 184.704)",
          "chart-3": "oklch(0.398 0.07 227.392)",
          "chart-4": "oklch(0.828 0.189 84.429)",
          "chart-5": "oklch(0.769 0.188 70.08)",
          "radius": "0.625rem",
          "sidebar": "oklch(0.985 0.002 247.839)",
          "sidebar-foreground": "oklch(0.13 0.028 261.692)",
          "sidebar-primary": "oklch(0.21 0.034 264.665)",
          "sidebar-primary-foreground": "oklch(0.985 0.002 247.839)",
          "sidebar-accent": "oklch(0.967 0.003 264.542)",
          "sidebar-accent-foreground": "oklch(0.21 0.034 264.665)",
          "sidebar-border": "oklch(0.928 0.006 264.531)",
          "sidebar-ring": "oklch(0.707 0.022 261.325)"
        },
        "dark": {
          "background": "oklch(0.13 0.028 261.692)",
          "foreground": "oklch(0.985 0.002 247.839)",
          "card": "oklch(0.21 0.034 264.665)",
          "card-foreground": "oklch(0.985 0.002 247.839)",
          "popover": "oklch(0.21 0.034 264.665)",
          "popover-foreground": "oklch(0.985 0.002 247.839)",
          "primary": "oklch(0.928 0.006 264.531)",
          "primary-foreground": "oklch(0.21 0.034 264.665)",
          "secondary": "oklch(0.278 0.033 256.848)",
          "secondary-foreground": "oklch(0.985 0.002 247.839)",
          "muted": "oklch(0.278 0.033 256.848)",
          "muted-foreground": "oklch(0.707 0.022 261.325)",
          "accent": "oklch(0.278 0.033 256.848)",
          "accent-foreground": "oklch(0.985 0.002 247.839)",
          "destructive": "oklch(0.704 0.191 22.216)",
          "border": "oklch(1 0 0 / 10%)",
          "input": "oklch(1 0 0 / 15%)",
          "ring": "oklch(0.551 0.027 264.364)",
          "chart-1": "oklch(0.488 0.243 264.376)",
          "chart-2": "oklch(0.696 0.17 162.48)",
          "chart-3": "oklch(0.769 0.188 70.08)",
          "chart-4": "oklch(0.627 0.265 303.9)",
          "chart-5": "oklch(0.645 0.246 16.439)",
          "sidebar": "oklch(0.21 0.034 264.665)",
          "sidebar-foreground": "oklch(0.985 0.002 247.839)",
          "sidebar-primary": "oklch(0.488 0.243 264.376)",
          "sidebar-primary-foreground": "oklch(0.985 0.002 247.839)",
          "sidebar-accent": "oklch(0.278 0.033 256.848)",
          "sidebar-accent-foreground": "oklch(0.985 0.002 247.839)",
          "sidebar-border": "oklch(1 0 0 / 10%)",
          "sidebar-ring": "oklch(0.551 0.027 264.364)"
        }
      },
      "files": []
    },
    {
      "name": "theme-slate",
      "type": "registry:theme",
      "cssVars": {
        "light": {
          "background": "oklch(1 0 0)",
          "foreground": "oklch(0.129 0.042 264.695)",
          "card": "oklch(1 0 0)",
          "card-foreground": "oklch(0.129 0.042 264.695)",
          "popover": "oklch(1 0 0)",
          "popover-foreground": "oklch(0.129 0.042 264.695)",
          "primary": "oklch(0.208 0.042 265.755)",
          "primary-foreground": "oklch(0.984 0.003 247.858)",
          "secondary": "oklch(0.968 0.007 247.896)",
          "secondary-foreground": "oklch(0.208 0.042 265.755)",
          "muted": "oklch(0.968 0.007 247.896)",
          "muted-foreground": "oklch(0.554 0.046 257.417)",
          "accent": "oklch(0.968 0.007 247.896)",
          "accent-foreground": "oklch(0.208 0.042 265.755)",
          "destructive": "oklch(0.577 0.245 27.325)",
          "border": "oklch(0.929 0.013 255.508)",
          "input": "oklch(0.929 0.013 255.508)",
          "ring": "oklch(0.704 0.04 256.788)",
          "chart-1": "oklch(0.646 0.222 41.116)",
          "chart-2": "oklch(0.6 0.118 184.704)",
          "chart-3": "oklch(0.398 0.07 227.392)",
          "chart-4": "oklch(0.828 0.189 84.429)",
          "chart-5": "oklch(0.769 0.188 70.08)",
          "radius": "0.625rem",
          "sidebar": "oklch(0.984 0.003 247.858)",
          "sidebar-foreground": "oklch(0.129 0.042 264.695)",
          "sidebar-primary": "oklch(0.208 0.042 265.755)",
          "sidebar-primary-foreground": "oklch(0.984 0.003 247.858)",
          "sidebar-accent": "oklch(0.968 0.007 247.896)",
          "sidebar-accent-foreground": "oklch(0.208 0.042 265.755)",
          "sidebar-border": "oklch(0.929 0.013 255.508)",
          "sidebar-ring": "oklch(0.704 0.04 256.788)"
        },
        "dark": {
          "background": "oklch(0.129 0.042 264.695)",
          "foreground": "oklch(0.984 0.003 247.858)",
          "card": "oklch(0.208 0.042 265.755)",
          "card-foreground": "oklch(0.984 0.003 247.858)",
          "popover": "oklch(0.208 0.042 265.755)",
          "popover-foreground": "oklch(0.984 0.003 247.858)",
          "primary": "oklch(0.929 0.013 255.508)",
          "primary-foreground": "oklch(0.208 0.042 265.755)",
          "secondary": "oklch(0.279 0.041 260.031)",
          "secondary-foreground": "oklch(0.984 0.003 247.858)",
          "muted": "oklch(0.279 0.041 260.031)",
          "muted-foreground": "oklch(0.704 0.04 256.788)",
          "accent": "oklch(0.279 0.041 260.031)",
          "accent-foreground": "oklch(0.984 0.003 247.858)",
          "destructive": "oklch(0.704 0.191 22.216)",
          "border": "oklch(1 0 0 / 10%)",
          "input": "oklch(1 0 0 / 15%)",
          "ring": "oklch(0.551 0.027 264.364)",
          "chart-1": "oklch(0.488 0.243 264.376)",
          "chart-2": "oklch(0.696 0.17 162.48)",
          "chart-3": "oklch(0.769 0.188 70.08)",
          "chart-4": "oklch(0.627 0.265 303.9)",
          "chart-5": "oklch(0.645 0.246 16.439)",
          "sidebar": "oklch(0.208 0.042 265.755)",
          "sidebar-foreground": "oklch(0.984 0.003 247.858)",
          "sidebar-primary": "oklch(0.488 0.243 264.376)",
          "sidebar-primary-foreground": "oklch(0.984 0.003 247.858)",
          "sidebar-accent": "oklch(0.279 0.041 260.031)",
          "sidebar-accent-foreground": "oklch(0.984 0.003 247.858)",
          "sidebar-border": "oklch(1 0 0 / 10%)",
          "sidebar-ring": "oklch(0.551 0.027 264.364)"
        }
      },
      "files": []
    },
    {
      "name": "particle-player",
      "description": "Audio player",
      "type": "registry:block",
      "registryDependencies": [
        "@audio/player",
        "@audio/queue",
        "@audio/store",
        "@audio/lib"
      ],
      "files": [
        {
          "path": "src/registry/default/particles/particle-player.tsx",
          "type": "registry:block",
          "target": "components/audio/particles/particle-player.tsx",
          "content": "\"use client\";\n\nimport {\n  AudioPlayer,\n  AudioPlayerControlBar,\n  AudioPlayerControlGroup,\n  AudioPlayerPlay,\n  AudioPlayerSeekBar,\n  AudioPlayerSkipBack,\n  AudioPlayerSkipForward,\n  AudioPlayerTimeDisplay,\n  AudioPlayerVolume,\n} from \"@/components/audio/player\";\nimport {\n  AudioQueue,\n  AudioQueueRepeatMode,\n  AudioQueueShuffle,\n} from \"@/components/audio/queue\";\n\nexport default function ParticleAudioPlayer() {\n  return (\n    <AudioPlayer>\n      <AudioPlayerControlBar variant=\"stacked\">\n        <AudioPlayerControlGroup>\n          <AudioPlayerTimeDisplay />\n          <AudioPlayerSeekBar />\n          <AudioPlayerTimeDisplay remaining />\n        </AudioPlayerControlGroup>\n        <AudioPlayerControlGroup>\n          <AudioPlayerControlGroup>\n            <AudioPlayerSkipBack />\n            <AudioPlayerPlay />\n            <AudioPlayerSkipForward />\n          </AudioPlayerControlGroup>\n          <AudioQueueShuffle />\n          <AudioQueueRepeatMode />\n          <AudioPlayerVolume />\n          <AudioQueue />\n        </AudioPlayerControlGroup>\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "player",
        "queue"
      ]
    },
    {
      "name": "particle-player-widget",
      "description": "Audio player widget",
      "type": "registry:block",
      "registryDependencies": [
        "@audio/provider",
        "@audio/player",
        "@audio/queue",
        "@audio/track",
        "@audio/store",
        "@audio/lib"
      ],
      "files": [
        {
          "path": "src/registry/default/particles/particle-player-widget.tsx",
          "type": "registry:block",
          "target": "components/audio/particles/particle-player-widget.tsx",
          "content": "\"use client\";\n\nimport {\n  AudioPlayer,\n  AudioPlayerControlBar,\n  AudioPlayerControlGroup,\n  AudioPlayerPlay,\n  AudioPlayerSeekBar,\n  AudioPlayerSkipBack,\n  AudioPlayerSkipForward,\n  AudioPlayerTimeDisplay,\n  AudioPlayerVolume,\n} from \"@/components/audio/player\";\nimport {\n  AudioQueueRepeatMode,\n  AudioQueueShuffle,\n} from \"@/components/audio/queue\";\nimport { AudioTrackList } from \"@/components/audio/track\";\n\nexport default function ParticlePlayerWidget() {\n  return (\n    <AudioPlayer className=\"flex flex-col gap-1.5\">\n      <AudioTrackList className=\"h-36 w-full rounded-sm border bg-muted/50 p-1\" />\n      <AudioPlayerControlBar variant=\"stacked\">\n        <AudioPlayerControlGroup>\n          <AudioPlayerTimeDisplay />\n          <AudioPlayerSeekBar />\n          <AudioPlayerTimeDisplay remaining />\n        </AudioPlayerControlGroup>\n        <AudioPlayerControlGroup>\n          <AudioPlayerControlGroup>\n            <AudioPlayerSkipBack />\n            <AudioPlayerPlay />\n            <AudioPlayerSkipForward />\n          </AudioPlayerControlGroup>\n          <AudioQueueShuffle />\n          <AudioQueueRepeatMode />\n          <AudioPlayerVolume />\n        </AudioPlayerControlGroup>\n      </AudioPlayerControlBar>\n    </AudioPlayer>\n  );\n}\n"
        }
      ],
      "categories": [
        "player",
        "widget"
      ]
    },
    {
      "name": "hooks",
      "type": "registry:hook",
      "registryDependencies": [],
      "files": []
    },
    {
      "name": "lib",
      "description": "Audio Lib",
      "type": "registry:lib",
      "dependencies": [],
      "registryDependencies": [],
      "files": [
        {
          "path": "src/registry/default/lib/audio.ts",
          "type": "registry:lib",
          "target": "lib/audio.ts",
          "content": "export type Track = {\n  id?: string | number;\n  url: string;\n  title?: string;\n  artist?: string;\n  artwork?: string;\n  images?: string[];\n  duration?: number;\n  album?: string;\n  genre?: string;\n  live?: boolean;\n  [key: string]: unknown;\n};\n\nclass AudioLib {\n  private audio: HTMLAudioElement | null = null;\n  private isInitialized = false;\n  private playPromise: Promise<void> | null = null;\n  private lastVolume = 1;\n  private fadeTimeout: NodeJS.Timeout | null = null;\n  private retryAttempts = 0;\n  private readonly maxRetries = 3;\n  private readonly eventTarget = new EventTarget();\n  /** Initialize the audio element and event listeners */\n  init(): void {\n    if (this.isInitialized || !this.isClient()) {\n      return;\n    }\n\n    this.isInitialized = true;\n\n    if (this.isClient()) {\n      this.audio = new Audio();\n      this.setupEventListeners();\n    }\n  }\n\n  private setupEventListeners(): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    if (!audio) {\n      return;\n    }\n\n    audio.addEventListener(\"error\", () => {\n      const errorDetails = {\n        code: audio.error?.code,\n        message: audio.error?.message,\n        event_type: `error_code_${audio.error?.code || \"unknown\"}`,\n        src: audio.src,\n        readyState: audio.readyState,\n        networkState: audio.networkState,\n        raw_error_object: audio.error,\n      };\n      console.error(\"### Detailed Audio Element Error ###\", errorDetails);\n\n      if (this.retryAttempts < this.maxRetries) {\n        this.retryAttempts += 1;\n\n        setTimeout(() => {\n          this.reloadAudio();\n        }, 1000);\n      }\n\n      this.eventTarget.dispatchEvent(new CustomEvent(\"audioError\"));\n    });\n\n    audio.addEventListener(\"playing\", () => {\n      this.retryAttempts = 0;\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingEnd\"));\n      this.eventTarget.dispatchEvent(new CustomEvent(\"playbackStarted\"));\n    });\n\n    audio.addEventListener(\"canplaythrough\", () => {\n      this.retryAttempts = 0;\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingEnd\"));\n    });\n\n    audio.addEventListener(\"waiting\", () => {\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingStart\"));\n    });\n\n    audio.addEventListener(\"progress\", () => {\n      const buffered = audio.buffered;\n      const currentTime = audio.currentTime;\n      let bufferedEnd = 0;\n\n      if (buffered.length === 0) {\n        return;\n      }\n\n      for (let i = buffered.length - 1; i >= 0; i--) {\n        if (buffered.start(i) <= currentTime) {\n          bufferedEnd = buffered.end(i);\n          break;\n        }\n      }\n\n      if (bufferedEnd === 0) {\n        bufferedEnd = buffered.end(0);\n      }\n\n      if (bufferedEnd > 0) {\n        this.eventTarget.dispatchEvent(\n          new CustomEvent(\"bufferUpdate\", {\n            detail: { bufferedTime: bufferedEnd },\n          })\n        );\n      }\n    });\n  }\n\n  cleanup(): void {\n    if (this.audio) {\n      this.audio.pause();\n      this.audio.src = \"\";\n      this.audio.load();\n    }\n\n    if (this.fadeTimeout) {\n      clearTimeout(this.fadeTimeout);\n      this.fadeTimeout = null;\n    }\n\n    this.playPromise = null;\n  }\n\n  getAudioElement(): HTMLAudioElement | null {\n    if (!this.isClient()) {\n      return null;\n    }\n    return this.audio;\n  }\n\n  private isClient(): boolean {\n    return typeof window !== \"undefined\" && !!window.document;\n  }\n\n  private ensureAudio(): HTMLAudioElement {\n    if (!this.isClient()) {\n      throw new Error(\"Audio module not available on server side\");\n    }\n    if (!this.audio) {\n      throw new Error(\"Audio module not initialized\");\n    }\n    return this.audio;\n  }\n\n  async load(url: string, startTime = 0, isLiveStream = false): Promise<void> {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    if (!audio) {\n      return;\n    }\n\n    try {\n      this.retryAttempts = 0;\n      if (audio.src === url) {\n        if (audio.currentTime !== startTime && !isLiveStream) {\n          audio.currentTime = startTime;\n        }\n        return;\n      }\n\n      audio.pause();\n      audio.src = \"\";\n\n      audio.src = url;\n      audio.preload = \"auto\";\n\n      const loadTimeout = isLiveStream ? 60_000 : 30_000;\n\n      await new Promise<void>((resolve, reject) => {\n        let timeoutId: NodeJS.Timeout | null = null;\n        let isResolved = false;\n\n        const cleanup = () => {\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n          }\n          audio.removeEventListener(\"loadedmetadata\", handleLoadSuccess);\n          audio.removeEventListener(\"canplay\", handleLoadSuccess);\n          audio.removeEventListener(\"canplaythrough\", handleLoadSuccess);\n          audio.removeEventListener(\"error\", handleErrorLoading);\n        };\n\n        const handleTimeout = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n\n          reject(\n            new Error(\n              `Audio load timeout (${loadTimeout / 1000}s). ReadyState: ${audio.readyState}, NetworkState: ${audio.networkState}, URL: ${audio.src}`\n            )\n          );\n        };\n\n        const handleLoadSuccess = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n\n          // Ne pas dfinir currentTime pour les streams live\n          if (startTime > 0 && !isLiveStream) {\n            audio.currentTime = startTime;\n          }\n          resolve();\n        };\n\n        const handleErrorLoading = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n          console.error(\"Error during initial audio load:\", audio.error);\n          reject(\n            new Error(\n              `Audio load failed: ${audio.error?.message || \"Unknown error\"}`\n            )\n          );\n        };\n\n        timeoutId = setTimeout(handleTimeout, loadTimeout);\n\n        audio.addEventListener(\"loadedmetadata\", handleLoadSuccess);\n        audio.addEventListener(\"canplay\", handleLoadSuccess);\n        audio.addEventListener(\"canplaythrough\", handleLoadSuccess);\n        audio.addEventListener(\"error\", handleErrorLoading);\n        audio.load();\n      });\n    } catch (error) {\n      console.error(\"Audio load process error:\", error);\n      throw error;\n    }\n  }\n\n  async play(): Promise<void> {\n    if (!this.isClient()) {\n      return;\n    }\n    if (!this.audio) {\n      throw new Error(\"Audio module not initialized\");\n    }\n\n    try {\n      if (!this.audio.paused) {\n        return;\n      }\n      this.playPromise = this.audio.play();\n      await this.playPromise;\n      this.playPromise = null;\n    } catch (error) {\n      this.playPromise = null;\n      const errorDetails = {\n        error,\n        message: error instanceof Error ? error.message : \"Unknown error\",\n        stack: error instanceof Error ? error.stack : undefined,\n        url: this.audio.src,\n        readyState: this.audio.readyState,\n        networkState: this.audio.networkState,\n      };\n      console.error(\"Play error:\", errorDetails);\n      throw error;\n    }\n  }\n\n  private reloadAudio(): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    const currentTime = audio.currentTime;\n    const wasPlaying = !audio.paused;\n    const currentSrc = audio.src;\n\n    audio.pause();\n    audio.src = \"\";\n    audio.load();\n    audio.src = currentSrc;\n    audio.preload = \"auto\";\n    audio.load();\n\n    const setTimeAndPlay = () => {\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = currentTime;\n        if (wasPlaying) {\n          this.play().catch(console.error);\n        }\n        audio.removeEventListener(\"loadedmetadata\", setTimeAndPlay);\n      }\n    };\n\n    audio.addEventListener(\"loadedmetadata\", setTimeAndPlay);\n  }\n\n  pause(): void {\n    if (!this.isClient()) {\n      return;\n    }\n    const audio = this.ensureAudio();\n\n    audio.pause();\n  }\n\n  setVolume(volume: number, fadeTime = 0): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n\n    if (this.fadeTimeout) {\n      clearTimeout(this.fadeTimeout);\n      this.fadeTimeout = null;\n    }\n\n    if (fadeTime <= 0) {\n      audio.volume = Math.max(0, Math.min(1, volume));\n      if (volume > 0) {\n        this.lastVolume = volume;\n      }\n      return;\n    }\n\n    this.fadeVolume(audio, volume, fadeTime);\n  }\n\n  private fadeVolume(\n    audio: HTMLAudioElement,\n    targetVolume: number,\n    duration: number\n  ): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const startVolume = audio.volume;\n    const endVolume = Math.max(0, Math.min(1, targetVolume));\n    const startTime = performance.now();\n\n    const updateVolume = () => {\n      const elapsed = performance.now() - startTime;\n      const progress = Math.min(1, elapsed / duration);\n      const currentVolume = startVolume + (endVolume - startVolume) * progress;\n\n      audio.volume = currentVolume;\n\n      if (progress < 1) {\n        this.fadeTimeout = setTimeout(updateVolume, 16);\n      } else {\n        if (endVolume > 0) {\n          this.lastVolume = endVolume;\n        }\n        this.fadeTimeout = null;\n      }\n    };\n\n    updateVolume();\n  }\n\n  getVolume(): number {\n    if (!this.isClient()) {\n      return 0;\n    }\n\n    const audio = this.ensureAudio();\n    return audio.volume;\n  }\n\n  setMuted(muted: boolean): void {\n    if (!this.isClient()) {\n      return;\n    }\n    const audio = this.ensureAudio();\n    if (audio.muted === muted) {\n      return;\n    }\n\n    if (muted) {\n      if (audio.volume > 0) {\n        this.lastVolume = audio.volume;\n      }\n      this.fadeVolume(audio, 0, 200);\n      audio.muted = true;\n    } else {\n      audio.muted = false;\n      this.fadeVolume(audio, this.lastVolume, 200);\n    }\n  }\n\n  getDuration(): number {\n    if (!this.isClient()) {\n      return 0;\n    }\n    const audio = this.ensureAudio();\n    return audio.duration;\n  }\n\n  getCurrentTime(): number {\n    if (!this.isClient()) {\n      return 0;\n    }\n    const audio = this.ensureAudio();\n    return audio.currentTime;\n  }\n\n  setCurrentTime(time: number): void {\n    if (!this.isClient()) {\n      return;\n    }\n    const audio = this.ensureAudio();\n    const duration = audio.duration;\n\n    if (!Number.isNaN(duration) && time >= 0 && time <= duration) {\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = time;\n      }\n    } else if (!Number.isNaN(duration)) {\n      const validTime = Math.max(0, Math.min(time, duration));\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = validTime;\n      }\n    }\n  }\n\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    this.eventTarget.addEventListener(type, listener, options);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n\n  getSource(): string {\n    if (!this.isClient()) {\n      return \"\";\n    }\n    const audio = this.ensureAudio();\n    return audio.src;\n  }\n\n  isPaused(): boolean {\n    if (!this.isClient()) {\n      return true;\n    }\n    const audio = this.ensureAudio();\n    return audio.paused;\n  }\n\n  getBufferedRanges(): TimeRanges | null {\n    if (!(this.isClient() && this.audio)) {\n      return null;\n    }\n    return this.audio.buffered;\n  }\n}\n\nexport const $audio = new AudioLib();\n\nconst MINUTE_IN_SECONDS = 60;\n\nconst LIVE_STREAM_PATTERNS = [\n  /\\/live\\./i,\n  /\\/stream/i,\n  /\\/radio/i,\n  /\\.m3u8$/i,\n  /\\.pls$/i,\n  /\\.aac$/i,\n  /icecast|shoutcast/i,\n];\n\nexport function isLive(track: Track): boolean {\n  if (!track.url) {\n    return false;\n  }\n\n  const url = track.url.toLowerCase();\n\n  for (const pattern of LIVE_STREAM_PATTERNS) {\n    if (pattern.test(url)) {\n      return true;\n    }\n  }\n\n  if (track.live === true) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function formatDuration(seconds: number): string {\n  if (!Number.isFinite(seconds) || seconds < 0) {\n    return \"0:00\";\n  }\n  const minutes = Math.floor(seconds / MINUTE_IN_SECONDS);\n  const remainingSeconds = Math.floor(seconds % MINUTE_IN_SECONDS);\n  return `${minutes}:${remainingSeconds < 10 ? \"0\" : \"\"}${remainingSeconds}`;\n}\n"
        }
      ],
      "categories": [
        "lib",
        "audio"
      ]
    },
    {
      "name": "store",
      "description": "Audio store",
      "type": "registry:lib",
      "dependencies": [
        "zustand"
      ],
      "registryDependencies": [
        "@audio/lib"
      ],
      "files": [
        {
          "path": "src/registry/default/lib/audio-store.ts",
          "type": "registry:lib",
          "target": "lib/audio-store.ts",
          "content": "import { create } from \"zustand\";\nimport { persist, subscribeWithSelector } from \"zustand/middleware\";\nimport { $audio, isLive, type Track } from \"@/lib/audio\";\n\ntype RepeatMode = \"none\" | \"one\" | \"all\";\ntype InsertMode = \"first\" | \"last\" | \"after\";\n\ntype AudioStore = {\n  // State\n  currentTrack: Track | null;\n  queue: Track[];\n  history: Track[];\n  isPlaying: boolean;\n  isLoading: boolean;\n  isBuffering: boolean;\n  volume: number;\n  isMuted: boolean;\n  repeatMode: RepeatMode;\n  shuffleEnabled: boolean;\n  currentTime: number;\n  duration: number;\n  progress: number;\n  bufferedTime: number;\n  insertMode: InsertMode;\n  isError: boolean;\n  errorMessage: string | null;\n  currentQueueIndex: number;\n\n  // Playback Actions\n  play: () => void;\n  pause: () => void;\n  togglePlay: () => void;\n  next: () => void;\n  previous: () => void;\n  seek: (time: number) => void;\n  setQueueAndPlay: (tracks: Track[], startIndex: number) => Promise<void>;\n  handleTrackEnd: () => void;\n\n  // Queue Actions\n  addToQueue: (track: Track, mode?: InsertMode) => void;\n  removeFromQueue: (trackId: string) => void;\n  clearQueue: () => void;\n  moveInQueue: (fromIndex: number, toIndex: number) => void;\n  setQueue: (tracks: Track[], startIndex?: number) => void;\n  getCurrentQueueIndex: () => number;\n  addTracksToEndOfQueue: (tracksToAdd: Track[]) => void;\n\n  // Control Actions\n  setVolume: (volume: number) => void;\n  toggleMute: () => void;\n  changeRepeatMode: () => void;\n  setInsertMode: (mode: InsertMode) => void;\n  shuffle: () => void;\n  unshuffle: () => void;\n  setRepeatMode: (mode: RepeatMode) => void;\n\n  // State Actions\n  setCurrentTrack: (track: Track | null) => void;\n  setError: (message: string | null) => void;\n};\n\nfunction canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n}\n\nconst calculateNextIndex = (\n  queue: Track[],\n  currentQueueIndex: number,\n  shuffleEnabled: boolean,\n  repeatMode: RepeatMode\n): number => {\n  if (queue.length === 0) {\n    return -1;\n  }\n\n  if (shuffleEnabled) {\n    if (queue.length === 1) {\n      return repeatMode === \"none\" ? -1 : 0;\n    }\n    let randomIndex: number;\n    do {\n      randomIndex = Math.floor(Math.random() * queue.length);\n    } while (randomIndex === currentQueueIndex);\n    return randomIndex;\n  }\n\n  let nextIndex = currentQueueIndex + 1;\n  if (nextIndex >= queue.length) {\n    if (repeatMode === \"all\") {\n      nextIndex = 0;\n    } else {\n      return -1;\n    }\n  }\n\n  return nextIndex >= 0 && nextIndex < queue.length ? nextIndex : -1;\n};\n\nconst calculatePreviousIndex = (\n  queue: Track[],\n  currentQueueIndex: number,\n  shuffleEnabled: boolean,\n  repeatMode: RepeatMode\n): number => {\n  if (queue.length === 0) {\n    return -1;\n  }\n\n  if (shuffleEnabled) {\n    if (queue.length === 1) {\n      return repeatMode === \"none\" ? -1 : 0;\n    }\n    let randomIndex: number;\n    do {\n      randomIndex = Math.floor(Math.random() * queue.length);\n    } while (randomIndex === currentQueueIndex);\n    return randomIndex;\n  }\n\n  let prevIndex = currentQueueIndex - 1;\n  if (prevIndex < 0) {\n    if (repeatMode === \"all\") {\n      prevIndex = queue.length - 1;\n    } else {\n      return -1;\n    }\n  }\n\n  return prevIndex >= 0 && prevIndex < queue.length ? prevIndex : -1;\n};\n\nconst useAudioStore = create<AudioStore>()(\n  persist(\n    subscribeWithSelector((set, get) => ({\n      // Initial State\n      currentTrack: null,\n      queue: [],\n      history: [],\n      isPlaying: false,\n      isLoading: false,\n      isBuffering: false,\n      volume: 1,\n      isMuted: false,\n      repeatMode: \"none\",\n      shuffleEnabled: false,\n      currentTime: 0,\n      duration: 0,\n      progress: 0,\n      bufferedTime: 0,\n      insertMode: \"last\",\n      isError: false,\n      errorMessage: null,\n      currentQueueIndex: -1,\n\n      // Playback Actions\n      async play() {\n        if (get().isLoading) {\n          return;\n        }\n        await $audio.play();\n      },\n\n      pause() {\n        $audio.pause();\n      },\n\n      togglePlay() {\n        if (get().isLoading) {\n          return;\n        }\n        if ($audio.isPaused()) {\n          get().play();\n        } else {\n          get().pause();\n        }\n      },\n\n      async next() {\n        const state = get();\n        const nextIndex = calculateNextIndex(\n          state.queue,\n          state.currentQueueIndex,\n          state.shuffleEnabled,\n          state.repeatMode\n        );\n\n        if (nextIndex === -1 || !state.queue[nextIndex]) {\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        const nextSong = state.queue[nextIndex];\n        const isLiveStream = isLive(nextSong);\n\n        set({ isLoading: true, isBuffering: true });\n        try {\n          set({\n            currentTrack: nextSong,\n            currentQueueIndex: nextIndex,\n          });\n          await $audio.load(nextSong.url, 0, isLiveStream);\n          await $audio.play();\n          set({\n            isLoading: false,\n            isError: false,\n            errorMessage: null,\n            isBuffering: false,\n          });\n        } catch {\n          set({\n            isLoading: false,\n            isPlaying: false,\n            isError: true,\n            errorMessage: \"Error loading/playing next track\",\n            isBuffering: false,\n          });\n        }\n      },\n\n      async previous() {\n        const state = get();\n        const currentTime = $audio.getCurrentTime();\n\n        if (currentTime > 3 && !state.shuffleEnabled) {\n          set({ isLoading: true });\n          try {\n            $audio.setCurrentTime(0);\n            set({ currentTime: 0, progress: 0, isLoading: false });\n            return;\n          } catch (error) {\n            console.error(\"Error restarting current track:\", error);\n            set({ isLoading: false });\n          }\n        }\n\n        const prevIndex = calculatePreviousIndex(\n          state.queue,\n          state.currentQueueIndex,\n          state.shuffleEnabled,\n          state.repeatMode\n        );\n\n        if (prevIndex === -1 || !state.queue[prevIndex]) {\n          if (prevIndex !== -1) {\n            console.error(\n              \"Inconsistency: previous index is valid but track not found\"\n            );\n          }\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        const prevSong = state.queue[prevIndex];\n        const isLiveStream = isLive(prevSong);\n\n        set({ isLoading: true, isBuffering: true });\n        try {\n          set({\n            currentTrack: prevSong,\n            currentQueueIndex: prevIndex,\n          });\n          await $audio.load(prevSong.url, 0, isLiveStream);\n          await $audio.play();\n          set({\n            isLoading: false,\n            isError: false,\n            errorMessage: null,\n            isBuffering: false,\n          });\n        } catch (error) {\n          console.error(\"Store Previous track error (load/play):\", error);\n          set({\n            isLoading: false,\n            isPlaying: false,\n            isError: true,\n            errorMessage: \"Error loading/playing previous track\",\n            isBuffering: false,\n          });\n        }\n      },\n\n      seek(time: number) {\n        $audio.setCurrentTime(time);\n        set({ currentTime: time });\n      },\n\n      async setQueueAndPlay(songs: Track[], startIndex: number) {\n        const targetSong = songs[startIndex];\n        if (!targetSong) {\n          console.error(\"[Playback] Invalid startIndex for setQueueAndPlay\");\n          get().clearQueue();\n          $audio.pause();\n          set({\n            isPlaying: false,\n            isLoading: false,\n            currentTrack: null,\n            currentQueueIndex: -1,\n          });\n          return;\n        }\n\n        get().setQueue(songs, startIndex);\n\n        const isLiveStream = isLive(targetSong);\n        set({ isLoading: true, isBuffering: true });\n        try {\n          set({\n            currentTrack: targetSong,\n            currentQueueIndex: startIndex,\n          });\n          await $audio.load(targetSong.url, 0, isLiveStream);\n          await $audio.play();\n          set({\n            isLoading: false,\n            isPlaying: true,\n            isError: false,\n            errorMessage: null,\n            isBuffering: false,\n          });\n        } catch (error) {\n          console.error(\n            \"[Playback] Error in setQueueAndPlay (load/play):\",\n            error\n          );\n          set({\n            isLoading: false,\n            isPlaying: false,\n            isError: true,\n            errorMessage: `Error playing ${targetSong.title}`,\n            isBuffering: false,\n          });\n        }\n      },\n\n      handleTrackEnd() {\n        get().next();\n      },\n\n      // Queue Actions\n      setQueue(tracks: Track[], startIndex = 0) {\n        const currentTrack = tracks[startIndex] ?? null;\n        set({\n          queue: tracks,\n          currentQueueIndex: currentTrack ? startIndex : -1,\n          currentTrack,\n        });\n      },\n\n      getCurrentQueueIndex() {\n        return get().currentQueueIndex;\n      },\n\n      addToQueue(track: Track, mode = \"last\") {\n        const state = get();\n        if (!state.currentTrack) {\n          set({\n            currentTrack: track,\n            currentQueueIndex: 0,\n            queue: [track],\n          });\n          return;\n        }\n\n        switch (mode) {\n          case \"first\":\n            set({\n              queue: [track, ...state.queue],\n              currentQueueIndex: state.currentQueueIndex + 1,\n            });\n            break;\n          case \"after\":\n            set({\n              queue: [\n                ...state.queue.slice(0, state.currentQueueIndex + 1),\n                track,\n                ...state.queue.slice(state.currentQueueIndex + 1),\n              ],\n            });\n            break;\n          default:\n            set({ queue: [...state.queue, track] });\n        }\n      },\n\n      removeFromQueue(trackId) {\n        const state = get();\n        const index = state.queue.findIndex((s) => s.id === trackId);\n        if (index === -1) {\n          return;\n        }\n\n        const newQueue = state.queue.filter((s) => s.id !== trackId);\n        set({\n          queue: newQueue,\n          currentQueueIndex:\n            index < state.currentQueueIndex\n              ? state.currentQueueIndex - 1\n              : state.currentQueueIndex,\n        });\n      },\n\n      clearQueue() {\n        set({ queue: [] });\n      },\n\n      moveInQueue(fromIndex, toIndex) {\n        const newQueue = [...get().queue];\n        const [movedItem] = newQueue.splice(fromIndex, 1);\n        if (!movedItem) {\n          return;\n        }\n\n        newQueue.splice(toIndex, 0, movedItem);\n        set({ queue: newQueue });\n      },\n\n      addTracksToEndOfQueue(tracksToAdd: Track[]) {\n        if (!tracksToAdd || tracksToAdd.length === 0) {\n          return;\n        }\n\n        const state = get();\n        const currentQueueIds = new Set(state.queue.map((s) => s.id));\n        const newTracks = tracksToAdd.filter(\n          (track) => !currentQueueIds.has(track.id)\n        );\n\n        if (newTracks.length > 0) {\n          set({ queue: [...state.queue, ...newTracks] });\n        }\n      },\n\n      // Control Actions\n      setVolume(volume) {\n        $audio.setVolume(volume);\n        set({ volume, isMuted: volume === 0 });\n      },\n\n      toggleMute() {\n        const newMuted = !get().isMuted;\n        $audio.setMuted(newMuted);\n        set({ isMuted: newMuted });\n      },\n\n      changeRepeatMode() {\n        const modes: RepeatMode[] = [\"none\", \"one\", \"all\"];\n        const currentIndex = modes.indexOf(get().repeatMode);\n        const newMode = modes[(currentIndex + 1) % modes.length];\n        set({ repeatMode: newMode });\n      },\n\n      setRepeatMode(mode) {\n        set({ repeatMode: mode });\n      },\n\n      setInsertMode(mode) {\n        set({ insertMode: mode });\n      },\n\n      shuffle() {\n        const state = get();\n        if (\n          !state.queue.length ||\n          state.queue.length < 2 ||\n          !state.currentTrack\n        ) {\n          return;\n        }\n\n        const remainingQueue = state.queue.filter(\n          (_, index) => index !== state.currentQueueIndex\n        );\n        const shuffledRemaining = remainingQueue.sort(\n          () => Math.random() - 0.5\n        );\n        const newQueue = [state.currentTrack, ...shuffledRemaining];\n\n        set({\n          queue: newQueue,\n          currentQueueIndex: 0,\n          shuffleEnabled: true,\n        });\n      },\n\n      unshuffle() {\n        set({ shuffleEnabled: false });\n      },\n\n      // State Actions\n      setCurrentTrack: (track: Track | null) => {\n        const performSetCurrentTrack = async () => {\n          const state = get();\n\n          if (!track) {\n            $audio.cleanup();\n            set({\n              currentTrack: null,\n              currentQueueIndex: -1,\n              isPlaying: false,\n              currentTime: 0,\n              duration: 0,\n              queue: [],\n              isLoading: false,\n              isError: false,\n              errorMessage: null,\n            });\n            return;\n          }\n\n          if (state.currentTrack?.id === track.id) {\n            return;\n          }\n\n          const isLiveStream = isLive(track);\n\n          try {\n            set({\n              currentTrack: track,\n              queue: [track],\n              currentQueueIndex: 0,\n              isLoading: true,\n              isPlaying: false,\n              currentTime: 0,\n              duration: 0,\n              isError: false,\n              errorMessage: null,\n            });\n\n            await $audio.load(track.url, 0, isLiveStream);\n            await $audio.play();\n          } catch (error) {\n            console.error(\"Error setting single current track:\", error);\n            set({\n              isLoading: false,\n              isPlaying: false,\n              isError: true,\n              errorMessage: `Error: ${error instanceof Error ? error.message : \"Unknown\"}`,\n            });\n          }\n        };\n\n        performSetCurrentTrack();\n      },\n      setError: (message) => {\n        set({\n          isError: !!message,\n          errorMessage: message,\n          isLoading: false,\n          isPlaying: false,\n        });\n      },\n    })),\n    {\n      name: \"audio:ui:store\",\n      partialize: (state) => ({\n        currentTrack: state.currentTrack,\n        queue: state.queue,\n        history: state.history,\n        volume: state.volume,\n        isMuted: state.isMuted,\n        repeatMode: state.repeatMode,\n        shuffleEnabled: state.shuffleEnabled,\n        currentTime: state.currentTime,\n        insertMode: state.insertMode,\n        currentQueueIndex: state.currentQueueIndex,\n      }),\n    }\n  )\n);\n\nexport {\n  calculateNextIndex,\n  calculatePreviousIndex,\n  canUseDOM,\n  useAudioStore,\n  type AudioStore,\n  type RepeatMode,\n  type InsertMode,\n};\n"
        }
      ],
      "categories": [
        "lib",
        "audio",
        "store"
      ]
    }
  ]
}