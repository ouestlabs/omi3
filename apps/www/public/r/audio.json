{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "audio",
  "type": "registry:lib",
  "description": "Audio Lib",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "src/registry/default/lib/audio.ts",
      "content": "export type Track = {\n  id?: string | number;\n  url: string;\n  title?: string;\n  artist?: string;\n  artwork?: string;\n  images?: string[];\n  duration?: number;\n  album?: string;\n  genre?: string;\n  live?: boolean;\n  [key: string]: unknown;\n};\n\nclass AudioLib {\n  private audio: HTMLAudioElement | null = null;\n  private isInitialized = false;\n  private playPromise: Promise<void> | null = null;\n  private lastVolume = 1;\n  private fadeTimeout: NodeJS.Timeout | null = null;\n  private retryAttempts = 0;\n  private readonly maxRetries = 3;\n  private readonly eventTarget = new EventTarget();\n  /** Initialize the audio element and event listeners */\n  init(): void {\n    if (this.isInitialized || !this.isClient()) {\n      return;\n    }\n\n    this.isInitialized = true;\n\n    if (this.isClient()) {\n      this.audio = new Audio();\n      this.setupEventListeners();\n    }\n  }\n\n  private setupEventListeners(): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    if (!audio) {\n      return;\n    }\n\n    audio.addEventListener(\"error\", () => {\n      const errorDetails = {\n        code: audio.error?.code,\n        message: audio.error?.message,\n        event_type: `error_code_${audio.error?.code || \"unknown\"}`,\n        src: audio.src,\n        readyState: audio.readyState,\n        networkState: audio.networkState,\n        raw_error_object: audio.error,\n      };\n      console.error(\"### Detailed Audio Element Error ###\", errorDetails);\n\n      if (this.retryAttempts < this.maxRetries) {\n        this.retryAttempts += 1;\n\n        setTimeout(() => {\n          this.reloadAudio();\n        }, 1000);\n      }\n\n      this.eventTarget.dispatchEvent(new CustomEvent(\"audioError\"));\n    });\n\n    audio.addEventListener(\"playing\", () => {\n      this.retryAttempts = 0;\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingEnd\"));\n      this.eventTarget.dispatchEvent(new CustomEvent(\"playbackStarted\"));\n    });\n\n    audio.addEventListener(\"canplaythrough\", () => {\n      this.retryAttempts = 0;\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingEnd\"));\n    });\n\n    audio.addEventListener(\"waiting\", () => {\n      this.eventTarget.dispatchEvent(new CustomEvent(\"bufferingStart\"));\n    });\n\n    audio.addEventListener(\"progress\", () => {\n      const buffered = audio.buffered;\n      const currentTime = audio.currentTime;\n      let bufferedEnd = 0;\n\n      if (buffered.length === 0) {\n        return;\n      }\n\n      for (let i = buffered.length - 1; i >= 0; i--) {\n        if (buffered.start(i) <= currentTime) {\n          bufferedEnd = buffered.end(i);\n          break;\n        }\n      }\n\n      if (bufferedEnd === 0) {\n        bufferedEnd = buffered.end(0);\n      }\n\n      if (bufferedEnd > 0) {\n        this.eventTarget.dispatchEvent(\n          new CustomEvent(\"bufferUpdate\", {\n            detail: { bufferedTime: bufferedEnd },\n          })\n        );\n      }\n    });\n  }\n\n  cleanup(): void {\n    if (this.audio) {\n      this.audio.pause();\n      this.audio.src = \"\";\n      this.audio.load();\n    }\n\n    if (this.fadeTimeout) {\n      clearTimeout(this.fadeTimeout);\n      this.fadeTimeout = null;\n    }\n\n    this.playPromise = null;\n  }\n\n  getAudioElement(): HTMLAudioElement | null {\n    if (!this.isClient()) {\n      return null;\n    }\n    return this.audio;\n  }\n\n  private isClient(): boolean {\n    return typeof window !== \"undefined\" && !!window.document;\n  }\n\n  private ensureAudio(): HTMLAudioElement {\n    if (!this.isClient()) {\n      throw new Error(\"Audio module not available on server side\");\n    }\n    if (!this.audio) {\n      throw new Error(\"Audio module not initialized\");\n    }\n    return this.audio;\n  }\n\n  async load(url: string, startTime = 0, isLiveStream = false): Promise<void> {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    if (!audio) {\n      return;\n    }\n\n    try {\n      this.retryAttempts = 0;\n      if (audio.src === url) {\n        if (audio.currentTime !== startTime && !isLiveStream) {\n          audio.currentTime = startTime;\n        }\n        return;\n      }\n\n      audio.pause();\n      audio.src = \"\";\n\n      audio.src = url;\n      audio.preload = \"auto\";\n\n      const loadTimeout = isLiveStream ? 60_000 : 30_000;\n\n      await new Promise<void>((resolve, reject) => {\n        let timeoutId: NodeJS.Timeout | null = null;\n        let isResolved = false;\n\n        const cleanup = () => {\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n          }\n          audio.removeEventListener(\"loadedmetadata\", handleLoadSuccess);\n          audio.removeEventListener(\"canplay\", handleLoadSuccess);\n          audio.removeEventListener(\"canplaythrough\", handleLoadSuccess);\n          audio.removeEventListener(\"error\", handleErrorLoading);\n        };\n\n        const handleTimeout = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n\n          reject(\n            new Error(\n              `Audio load timeout (${loadTimeout / 1000}s). ReadyState: ${audio.readyState}, NetworkState: ${audio.networkState}, URL: ${audio.src}`\n            )\n          );\n        };\n\n        const handleLoadSuccess = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n\n          // Ne pas dÃ©finir currentTime pour les streams live\n          if (startTime > 0 && !isLiveStream) {\n            audio.currentTime = startTime;\n          }\n          resolve();\n        };\n\n        const handleErrorLoading = () => {\n          if (isResolved) {\n            return;\n          }\n          isResolved = true;\n          cleanup();\n          console.error(\"Error during initial audio load:\", audio.error);\n          reject(\n            new Error(\n              `Audio load failed: ${audio.error?.message || \"Unknown error\"}`\n            )\n          );\n        };\n\n        timeoutId = setTimeout(handleTimeout, loadTimeout);\n\n        audio.addEventListener(\"loadedmetadata\", handleLoadSuccess);\n        audio.addEventListener(\"canplay\", handleLoadSuccess);\n        audio.addEventListener(\"canplaythrough\", handleLoadSuccess);\n        audio.addEventListener(\"error\", handleErrorLoading);\n        audio.load();\n      });\n    } catch (error) {\n      console.error(\"Audio load process error:\", error);\n      throw error;\n    }\n  }\n\n  async play(): Promise<void> {\n    if (!this.isClient()) {\n      return;\n    }\n    if (!this.audio) {\n      throw new Error(\"Audio module not initialized\");\n    }\n\n    try {\n      if (!this.audio.paused) {\n        return;\n      }\n      this.playPromise = this.audio.play();\n      await this.playPromise;\n      this.playPromise = null;\n    } catch (error) {\n      this.playPromise = null;\n      const errorDetails = {\n        error,\n        message: error instanceof Error ? error.message : \"Unknown error\",\n        stack: error instanceof Error ? error.stack : undefined,\n        url: this.audio.src,\n        readyState: this.audio.readyState,\n        networkState: this.audio.networkState,\n      };\n      console.error(\"Play error:\", errorDetails);\n      throw error;\n    }\n  }\n\n  private reloadAudio(): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n    const currentTime = audio.currentTime;\n    const wasPlaying = !audio.paused;\n    const currentSrc = audio.src;\n\n    audio.pause();\n    audio.src = \"\";\n    audio.load();\n    audio.src = currentSrc;\n    audio.preload = \"auto\";\n    audio.load();\n\n    const setTimeAndPlay = () => {\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = currentTime;\n        if (wasPlaying) {\n          this.play().catch(console.error);\n        }\n        audio.removeEventListener(\"loadedmetadata\", setTimeAndPlay);\n      }\n    };\n\n    audio.addEventListener(\"loadedmetadata\", setTimeAndPlay);\n  }\n\n  pause(): void {\n    if (!this.isClient()) {\n      return;\n    }\n    const audio = this.ensureAudio();\n\n    audio.pause();\n  }\n\n  setVolume(volume: number, fadeTime = 0): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const audio = this.ensureAudio();\n\n    if (this.fadeTimeout) {\n      clearTimeout(this.fadeTimeout);\n      this.fadeTimeout = null;\n    }\n\n    if (fadeTime <= 0) {\n      audio.volume = Math.max(0, Math.min(1, volume));\n      if (volume > 0) {\n        this.lastVolume = volume;\n      }\n      return;\n    }\n\n    this.fadeVolume(audio, volume, fadeTime);\n  }\n\n  private fadeVolume(\n    audio: HTMLAudioElement,\n    targetVolume: number,\n    duration: number\n  ): void {\n    if (!this.isClient()) {\n      return;\n    }\n\n    const startVolume = audio.volume;\n    const endVolume = Math.max(0, Math.min(1, targetVolume));\n    const startTime = performance.now();\n\n    const updateVolume = () => {\n      const elapsed = performance.now() - startTime;\n      const progress = Math.min(1, elapsed / duration);\n      const currentVolume = startVolume + (endVolume - startVolume) * progress;\n\n      audio.volume = currentVolume;\n\n      if (progress < 1) {\n        this.fadeTimeout = setTimeout(updateVolume, 16);\n      } else {\n        if (endVolume > 0) {\n          this.lastVolume = endVolume;\n        }\n        this.fadeTimeout = null;\n      }\n    };\n\n    updateVolume();\n  }\n\n  getVolume(): number {\n    if (!this.isClient()) {\n      return 0;\n    }\n\n    const audio = this.ensureAudio();\n    return audio.volume;\n  }\n\n  setMuted(muted: boolean): void {\n    if (!this.isClient()) {\n      return;\n    }\n    const audio = this.ensureAudio();\n    if (audio.muted === muted) {\n      return;\n    }\n\n    if (muted) {\n      if (audio.volume > 0) {\n        this.lastVolume = audio.volume;\n      }\n      this.fadeVolume(audio, 0, 200);\n      audio.muted = true;\n    } else {\n      audio.muted = false;\n      this.fadeVolume(audio, this.lastVolume, 200);\n    }\n  }\n\n  getDuration(): number {\n    if (!this.isClient()) {\n      return 0;\n    }\n    const audio = this.ensureAudio();\n    return audio.duration;\n  }\n\n  getCurrentTime(): number {\n    if (!this.isClient()) {\n      return 0;\n    }\n    const audio = this.ensureAudio();\n    return audio.currentTime;\n  }\n\n  setCurrentTime(time: number): void {\n    if (!this.isClient()) {\n      return;\n    }\n    const audio = this.ensureAudio();\n    const duration = audio.duration;\n\n    if (!Number.isNaN(duration) && time >= 0 && time <= duration) {\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = time;\n      }\n    } else if (!Number.isNaN(duration)) {\n      const validTime = Math.max(0, Math.min(time, duration));\n      if (audio.readyState >= audio.HAVE_METADATA) {\n        audio.currentTime = validTime;\n      }\n    }\n  }\n\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    this.eventTarget.addEventListener(type, listener, options);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n\n  getSource(): string {\n    if (!this.isClient()) {\n      return \"\";\n    }\n    const audio = this.ensureAudio();\n    return audio.src;\n  }\n\n  isPaused(): boolean {\n    if (!this.isClient()) {\n      return true;\n    }\n    const audio = this.ensureAudio();\n    return audio.paused;\n  }\n\n  getBufferedRanges(): TimeRanges | null {\n    if (!(this.isClient() && this.audio)) {\n      return null;\n    }\n    return this.audio.buffered;\n  }\n}\n\nexport const $audio = new AudioLib();\n\nconst MINUTE_IN_SECONDS = 60;\n\nconst LIVE_STREAM_PATTERNS = [\n  /\\/live\\./i,\n  /\\/stream/i,\n  /\\/radio/i,\n  /\\.m3u8$/i,\n  /\\.pls$/i,\n  /\\.aac$/i,\n  /icecast|shoutcast/i,\n];\n\nexport function isLive(track: Track): boolean {\n  if (!track.url) {\n    return false;\n  }\n\n  const url = track.url.toLowerCase();\n\n  for (const pattern of LIVE_STREAM_PATTERNS) {\n    if (pattern.test(url)) {\n      return true;\n    }\n  }\n\n  if (track.live === true) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function formatDuration(seconds: number): string {\n  if (!Number.isFinite(seconds) || seconds < 0) {\n    return \"0:00\";\n  }\n  const minutes = Math.floor(seconds / MINUTE_IN_SECONDS);\n  const remainingSeconds = Math.floor(seconds % MINUTE_IN_SECONDS);\n  return `${minutes}:${remainingSeconds < 10 ? \"0\" : \"\"}${remainingSeconds}`;\n}\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "lib",
    "audio"
  ]
}