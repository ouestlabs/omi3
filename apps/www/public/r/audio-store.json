{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "audio-store",
  "type": "registry:lib",
  "description": "Audio store",
  "dependencies": [
    "zustand"
  ],
  "registryDependencies": [
    "@audio/audio"
  ],
  "files": [
    {
      "path": "src/registry/default/lib/audio-store.ts",
      "content": "import { create } from \"zustand\";\nimport { persist, subscribeWithSelector } from \"zustand/middleware\";\nimport { $audio, isLive, type Track } from \"@/registry/default/lib/audio\";\n\ntype RepeatMode = \"none\" | \"one\" | \"all\";\ntype InsertMode = \"first\" | \"last\" | \"after\";\n\ntype AudioStore = {\n  // State\n  currentTrack: Track | null;\n  queue: Track[];\n  history: Track[];\n  isPlaying: boolean;\n  isLoading: boolean;\n  isBuffering: boolean;\n  volume: number;\n  isMuted: boolean;\n  repeatMode: RepeatMode;\n  shuffleEnabled: boolean;\n  currentTime: number;\n  duration: number;\n  progress: number;\n  bufferedTime: number;\n  insertMode: InsertMode;\n  isError: boolean;\n  errorMessage: string | null;\n  currentQueueIndex: number;\n\n  // Playback Actions\n  play: () => void;\n  pause: () => void;\n  togglePlay: () => void;\n  next: () => void;\n  previous: () => void;\n  seek: (time: number) => void;\n  setQueueAndPlay: (tracks: Track[], startIndex: number) => Promise<void>;\n  handleTrackEnd: () => void;\n\n  // Queue Actions\n  addToQueue: (track: Track, mode?: InsertMode) => void;\n  removeFromQueue: (trackId: string) => void;\n  clearQueue: () => void;\n  moveInQueue: (fromIndex: number, toIndex: number) => void;\n  setQueue: (tracks: Track[], startIndex?: number) => void;\n  getCurrentQueueIndex: () => number;\n  addTracksToEndOfQueue: (tracksToAdd: Track[]) => void;\n\n  // Control Actions\n  setVolume: (volume: number) => void;\n  toggleMute: () => void;\n  changeRepeatMode: () => void;\n  setInsertMode: (mode: InsertMode) => void;\n  shuffle: () => void;\n  unshuffle: () => void;\n  setRepeatMode: (mode: RepeatMode) => void;\n\n  // State Actions\n  setCurrentTrack: (track: Track | null) => void;\n  setError: (message: string | null) => void;\n};\n\nfunction canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n}\n\nconst calculateNextIndex = (\n  queue: Track[],\n  currentQueueIndex: number,\n  shuffleEnabled: boolean,\n  repeatMode: RepeatMode\n): number => {\n  if (queue.length === 0) {\n    return -1;\n  }\n\n  if (shuffleEnabled) {\n    if (queue.length === 1) {\n      return repeatMode === \"none\" ? -1 : 0;\n    }\n    let randomIndex: number;\n    do {\n      randomIndex = Math.floor(Math.random() * queue.length);\n    } while (randomIndex === currentQueueIndex);\n    return randomIndex;\n  }\n\n  let nextIndex = currentQueueIndex + 1;\n  if (nextIndex >= queue.length) {\n    if (repeatMode === \"all\") {\n      nextIndex = 0;\n    } else {\n      return -1;\n    }\n  }\n\n  return nextIndex >= 0 && nextIndex < queue.length ? nextIndex : -1;\n};\n\nconst calculatePreviousIndex = (\n  queue: Track[],\n  currentQueueIndex: number,\n  shuffleEnabled: boolean,\n  repeatMode: RepeatMode\n): number => {\n  if (queue.length === 0) {\n    return -1;\n  }\n\n  if (shuffleEnabled) {\n    if (queue.length === 1) {\n      return repeatMode === \"none\" ? -1 : 0;\n    }\n    let randomIndex: number;\n    do {\n      randomIndex = Math.floor(Math.random() * queue.length);\n    } while (randomIndex === currentQueueIndex);\n    return randomIndex;\n  }\n\n  let prevIndex = currentQueueIndex - 1;\n  if (prevIndex < 0) {\n    if (repeatMode === \"all\") {\n      prevIndex = queue.length - 1;\n    } else {\n      return -1;\n    }\n  }\n\n  return prevIndex >= 0 && prevIndex < queue.length ? prevIndex : -1;\n};\n\nconst useAudioStore = create<AudioStore>()(\n  persist(\n    subscribeWithSelector((set, get) => ({\n      // Initial State\n      currentTrack: null,\n      queue: [],\n      history: [],\n      isPlaying: false,\n      isLoading: false,\n      isBuffering: false,\n      volume: 1,\n      isMuted: false,\n      repeatMode: \"none\",\n      shuffleEnabled: false,\n      currentTime: 0,\n      duration: 0,\n      progress: 0,\n      bufferedTime: 0,\n      insertMode: \"last\",\n      isError: false,\n      errorMessage: null,\n      currentQueueIndex: -1,\n\n      // Playback Actions\n      async play() {\n        if (get().isLoading) {\n          return;\n        }\n        await $audio.play();\n      },\n\n      pause() {\n        $audio.pause();\n      },\n\n      togglePlay() {\n        if (get().isLoading) {\n          return;\n        }\n        if ($audio.isPaused()) {\n          get().play();\n        } else {\n          get().pause();\n        }\n      },\n\n      async next() {\n        const state = get();\n        const nextIndex = calculateNextIndex(\n          state.queue,\n          state.currentQueueIndex,\n          state.shuffleEnabled,\n          state.repeatMode\n        );\n\n        if (nextIndex === -1 || !state.queue[nextIndex]) {\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        const nextSong = state.queue[nextIndex];\n        const isLiveStream = isLive(nextSong);\n\n        set({ isLoading: true, isBuffering: true });\n        try {\n          set({\n            currentTrack: nextSong,\n            currentQueueIndex: nextIndex,\n          });\n          await $audio.load(nextSong.url, 0, isLiveStream);\n          await $audio.play();\n          set({\n            isLoading: false,\n            isError: false,\n            errorMessage: null,\n            isBuffering: false,\n          });\n        } catch {\n          set({\n            isLoading: false,\n            isPlaying: false,\n            isError: true,\n            errorMessage: \"Error loading/playing next track\",\n            isBuffering: false,\n          });\n        }\n      },\n\n      async previous() {\n        const state = get();\n        const currentTime = $audio.getCurrentTime();\n\n        if (currentTime > 3 && !state.shuffleEnabled) {\n          set({ isLoading: true });\n          try {\n            $audio.setCurrentTime(0);\n            set({ currentTime: 0, progress: 0, isLoading: false });\n            return;\n          } catch (error) {\n            console.error(\"Error restarting current track:\", error);\n            set({ isLoading: false });\n          }\n        }\n\n        const prevIndex = calculatePreviousIndex(\n          state.queue,\n          state.currentQueueIndex,\n          state.shuffleEnabled,\n          state.repeatMode\n        );\n\n        if (prevIndex === -1 || !state.queue[prevIndex]) {\n          if (prevIndex !== -1) {\n            console.error(\n              \"Inconsistency: previous index is valid but track not found\"\n            );\n          }\n          $audio.pause();\n          set({ isLoading: false, isPlaying: false, isBuffering: false });\n          return;\n        }\n\n        const prevSong = state.queue[prevIndex];\n        const isLiveStream = isLive(prevSong);\n\n        set({ isLoading: true, isBuffering: true });\n        try {\n          set({\n            currentTrack: prevSong,\n            currentQueueIndex: prevIndex,\n          });\n          await $audio.load(prevSong.url, 0, isLiveStream);\n          await $audio.play();\n          set({\n            isLoading: false,\n            isError: false,\n            errorMessage: null,\n            isBuffering: false,\n          });\n        } catch (error) {\n          console.error(\"Store Previous track error (load/play):\", error);\n          set({\n            isLoading: false,\n            isPlaying: false,\n            isError: true,\n            errorMessage: \"Error loading/playing previous track\",\n            isBuffering: false,\n          });\n        }\n      },\n\n      seek(time: number) {\n        $audio.setCurrentTime(time);\n        set({ currentTime: time });\n      },\n\n      async setQueueAndPlay(songs: Track[], startIndex: number) {\n        const targetSong = songs[startIndex];\n        if (!targetSong) {\n          console.error(\"[Playback] Invalid startIndex for setQueueAndPlay\");\n          get().clearQueue();\n          $audio.pause();\n          set({\n            isPlaying: false,\n            isLoading: false,\n            currentTrack: null,\n            currentQueueIndex: -1,\n          });\n          return;\n        }\n\n        get().setQueue(songs, startIndex);\n\n        const isLiveStream = isLive(targetSong);\n        set({ isLoading: true, isBuffering: true });\n        try {\n          set({\n            currentTrack: targetSong,\n            currentQueueIndex: startIndex,\n          });\n          await $audio.load(targetSong.url, 0, isLiveStream);\n          await $audio.play();\n          set({\n            isLoading: false,\n            isPlaying: true,\n            isError: false,\n            errorMessage: null,\n            isBuffering: false,\n          });\n        } catch (error) {\n          console.error(\n            \"[Playback] Error in setQueueAndPlay (load/play):\",\n            error\n          );\n          set({\n            isLoading: false,\n            isPlaying: false,\n            isError: true,\n            errorMessage: `Error playing ${targetSong.title}`,\n            isBuffering: false,\n          });\n        }\n      },\n\n      handleTrackEnd() {\n        get().next();\n      },\n\n      // Queue Actions\n      setQueue(tracks: Track[], startIndex = 0) {\n        const currentTrack = tracks[startIndex] ?? null;\n        set({\n          queue: tracks,\n          currentQueueIndex: currentTrack ? startIndex : -1,\n          currentTrack,\n        });\n      },\n\n      getCurrentQueueIndex() {\n        return get().currentQueueIndex;\n      },\n\n      addToQueue(track: Track, mode = \"last\") {\n        const state = get();\n        if (!state.currentTrack) {\n          set({\n            currentTrack: track,\n            currentQueueIndex: 0,\n            queue: [track],\n          });\n          return;\n        }\n\n        switch (mode) {\n          case \"first\":\n            set({\n              queue: [track, ...state.queue],\n              currentQueueIndex: state.currentQueueIndex + 1,\n            });\n            break;\n          case \"after\":\n            set({\n              queue: [\n                ...state.queue.slice(0, state.currentQueueIndex + 1),\n                track,\n                ...state.queue.slice(state.currentQueueIndex + 1),\n              ],\n            });\n            break;\n          default:\n            set({ queue: [...state.queue, track] });\n        }\n      },\n\n      removeFromQueue(trackId) {\n        const state = get();\n        const index = state.queue.findIndex((s) => s.id === trackId);\n        if (index === -1) {\n          return;\n        }\n\n        const newQueue = state.queue.filter((s) => s.id !== trackId);\n        set({\n          queue: newQueue,\n          currentQueueIndex:\n            index < state.currentQueueIndex\n              ? state.currentQueueIndex - 1\n              : state.currentQueueIndex,\n        });\n      },\n\n      clearQueue() {\n        set({ queue: [] });\n      },\n\n      moveInQueue(fromIndex, toIndex) {\n        const newQueue = [...get().queue];\n        const [movedItem] = newQueue.splice(fromIndex, 1);\n        if (!movedItem) {\n          return;\n        }\n\n        newQueue.splice(toIndex, 0, movedItem);\n        set({ queue: newQueue });\n      },\n\n      addTracksToEndOfQueue(tracksToAdd: Track[]) {\n        if (!tracksToAdd || tracksToAdd.length === 0) {\n          return;\n        }\n\n        const state = get();\n        const currentQueueIds = new Set(state.queue.map((s) => s.id));\n        const newTracks = tracksToAdd.filter(\n          (track) => !currentQueueIds.has(track.id)\n        );\n\n        if (newTracks.length > 0) {\n          set({ queue: [...state.queue, ...newTracks] });\n        }\n      },\n\n      // Control Actions\n      setVolume(volume) {\n        $audio.setVolume(volume);\n        set({ volume, isMuted: volume === 0 });\n      },\n\n      toggleMute() {\n        const newMuted = !get().isMuted;\n        $audio.setMuted(newMuted);\n        set({ isMuted: newMuted });\n      },\n\n      changeRepeatMode() {\n        const modes: RepeatMode[] = [\"none\", \"one\", \"all\"];\n        const currentIndex = modes.indexOf(get().repeatMode);\n        const newMode = modes[(currentIndex + 1) % modes.length];\n        set({ repeatMode: newMode });\n      },\n\n      setRepeatMode(mode) {\n        set({ repeatMode: mode });\n      },\n\n      setInsertMode(mode) {\n        set({ insertMode: mode });\n      },\n\n      shuffle() {\n        const state = get();\n        if (\n          !state.queue.length ||\n          state.queue.length < 2 ||\n          !state.currentTrack\n        ) {\n          return;\n        }\n\n        const remainingQueue = state.queue.filter(\n          (_, index) => index !== state.currentQueueIndex\n        );\n        const shuffledRemaining = remainingQueue.sort(\n          () => Math.random() - 0.5\n        );\n        const newQueue = [state.currentTrack, ...shuffledRemaining];\n\n        set({\n          queue: newQueue,\n          currentQueueIndex: 0,\n          shuffleEnabled: true,\n        });\n      },\n\n      unshuffle() {\n        set({ shuffleEnabled: false });\n      },\n\n      // State Actions\n      setCurrentTrack: (track: Track | null) => {\n        const performSetCurrentTrack = async () => {\n          const state = get();\n\n          if (!track) {\n            $audio.cleanup();\n            set({\n              currentTrack: null,\n              currentQueueIndex: -1,\n              isPlaying: false,\n              currentTime: 0,\n              duration: 0,\n              queue: [],\n              isLoading: false,\n              isError: false,\n              errorMessage: null,\n            });\n            return;\n          }\n\n          if (state.currentTrack?.id === track.id) {\n            return;\n          }\n\n          const isLiveStream = isLive(track);\n\n          try {\n            set({\n              currentTrack: track,\n              queue: [track],\n              currentQueueIndex: 0,\n              isLoading: true,\n              isPlaying: false,\n              currentTime: 0,\n              duration: 0,\n              isError: false,\n              errorMessage: null,\n            });\n\n            await $audio.load(track.url, 0, isLiveStream);\n            await $audio.play();\n          } catch (error) {\n            console.error(\"Error setting single current track:\", error);\n            set({\n              isLoading: false,\n              isPlaying: false,\n              isError: true,\n              errorMessage: `Error: ${error instanceof Error ? error.message : \"Unknown\"}`,\n            });\n          }\n        };\n\n        performSetCurrentTrack();\n      },\n      setError: (message) => {\n        set({\n          isError: !!message,\n          errorMessage: message,\n          isLoading: false,\n          isPlaying: false,\n        });\n      },\n    })),\n    {\n      name: \"audio:ui:store\",\n      partialize: (state) => ({\n        currentTrack: state.currentTrack,\n        queue: state.queue,\n        history: state.history,\n        volume: state.volume,\n        isMuted: state.isMuted,\n        repeatMode: state.repeatMode,\n        shuffleEnabled: state.shuffleEnabled,\n        currentTime: state.currentTime,\n        insertMode: state.insertMode,\n        currentQueueIndex: state.currentQueueIndex,\n      }),\n    }\n  )\n);\n\nexport {\n  calculateNextIndex,\n  calculatePreviousIndex,\n  canUseDOM,\n  useAudioStore,\n  type AudioStore,\n  type RepeatMode,\n  type InsertMode,\n};\n",
      "type": "registry:lib"
    }
  ],
  "categories": [
    "lib",
    "audio",
    "store"
  ]
}