{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "provider",
  "type": "registry:ui",
  "dependencies": [
    "zustand"
  ],
  "registryDependencies": [
    "@audio/store",
    "@audio/audio"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/audio/provider.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport { $audio, isLive, type Track } from \"@/registry/default/lib/audio\";\nimport {\n  type AudioStore,\n  calculateNextIndex,\n  canUseDOM,\n  useAudioStore,\n} from \"@/registry/default/lib/audio-store\";\n\nconst MAX_ERROR_RETRIES = 3;\nconst ERROR_RETRY_DELAY = 1000;\n\nfunction AudioProvider({\n  tracks = [],\n  children,\n}: {\n  tracks?: Track[];\n  children: React.ReactNode;\n}) {\n  const preloadAudioRef = React.useRef<HTMLAudioElement | null>(null);\n  const errorRetryCountRef = React.useRef<number>(0);\n  const throttleInterval = 100;\n  const minUpdateThreshold = 0.5;\n\n  const setState = React.useCallback(\n    (\n      partial:\n        | Partial<AudioStore>\n        | ((state: AudioStore) => Partial<AudioStore>)\n    ) => {\n      useAudioStore.setState(partial);\n    },\n    []\n  );\n\n  React.useEffect(() => {\n    if (tracks && tracks.length > 0) {\n      const state = useAudioStore.getState();\n      const currentQueue = state.queue;\n      const tracksChanged =\n        currentQueue.length === 0 ||\n        currentQueue.length !== tracks.length ||\n        currentQueue.some((track, index) => track.id !== tracks[index]?.id);\n\n      if (tracksChanged) {\n        const firstTrack = tracks[0];\n        useAudioStore.setState({\n          queue: tracks,\n          currentTrack: state.currentTrack || firstTrack,\n          currentQueueIndex:\n            state.currentQueueIndex === -1 ? 0 : state.currentQueueIndex,\n        });\n      }\n    }\n  }, [tracks]);\n\n  const retryPlayback = React.useCallback(async (audio: HTMLAudioElement) => {\n    if (errorRetryCountRef.current >= MAX_ERROR_RETRIES) {\n      return false;\n    }\n\n    errorRetryCountRef.current += 1;\n\n    const delay = 2 ** (errorRetryCountRef.current - 1) * ERROR_RETRY_DELAY;\n    await new Promise((resolve) => setTimeout(resolve, delay));\n\n    if (typeof navigator !== \"undefined\" && !navigator.onLine) {\n      console.warn(\"Offline, delaying retry attempt further.\");\n      return false;\n    }\n\n    try {\n      console.log(\n        `Retry attempt ${errorRetryCountRef.current}: Loading audio...`\n      );\n      const currentTime = audio.currentTime;\n      const wasPlaying = !audio.paused;\n      const state = useAudioStore.getState();\n      if (state.currentTrack) {\n        await $audio.load(state.currentTrack.url, currentTime);\n        if (wasPlaying) {\n          await $audio.play();\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error(\"Retry attempt failed:\", error);\n      return false;\n    }\n  }, []);\n\n  const lastUpdateTimeRef = React.useRef<number>(0);\n  const throttledTimeUpdate = React.useCallback(() => {\n    const now = Date.now();\n    if (now - lastUpdateTimeRef.current < throttleInterval) {\n      return;\n    }\n    lastUpdateTimeRef.current = now;\n\n    const audio = $audio.getAudioElement();\n    if (!audio) {\n      return;\n    }\n\n    const currentTime = audio.currentTime;\n    const state = useAudioStore.getState();\n\n    if (Math.abs(state.currentTime - currentTime) > minUpdateThreshold) {\n      const duration = audio.duration;\n      const newProgress = duration > 0 ? (currentTime / duration) * 100 : 0;\n      useAudioStore.setState({ currentTime, progress: newProgress });\n    }\n  }, []);\n\n  const preloadTrack = React.useCallback((song: Track) => {\n    if (!preloadAudioRef.current || preloadAudioRef.current.src === song.url) {\n      return;\n    }\n\n    try {\n      preloadAudioRef.current.src = song.url;\n      preloadAudioRef.current.preload = \"auto\";\n      preloadAudioRef.current.load();\n    } catch (error) {\n      console.error(\"Failed to preload next track:\", error);\n      if (preloadAudioRef.current) {\n        preloadAudioRef.current.src = \"\";\n      }\n    }\n  }, []);\n\n  const preloadNextTrack = React.useCallback(() => {\n    if (!preloadAudioRef.current) {\n      return;\n    }\n\n    const state = useAudioStore.getState();\n    const nextIndex = calculateNextIndex(\n      state.queue,\n      state.currentQueueIndex,\n      state.shuffleEnabled,\n      state.repeatMode\n    );\n\n    if (nextIndex === -1 || nextIndex >= state.queue.length) {\n      return;\n    }\n\n    const nextSong = state.queue[nextIndex];\n    if (!nextSong || nextSong.id === state.currentTrack?.id) {\n      return;\n    }\n\n    preloadTrack(nextSong);\n  }, [preloadTrack]);\n\n  React.useEffect(() => {\n    if (!canUseDOM()) {\n      return;\n    }\n\n    $audio.init();\n\n    preloadAudioRef.current = new Audio();\n    preloadAudioRef.current.muted = true;\n    preloadAudioRef.current.preload = \"none\";\n\n    const audio = $audio.getAudioElement();\n    if (!audio) {\n      console.error(\"Audio element initialization failed\");\n      return;\n    }\n\n    const handlePlay = () => {\n      errorRetryCountRef.current = 0;\n      setState({ isPlaying: true, isLoading: false, isBuffering: false });\n      preloadNextTrack();\n    };\n\n    const handlePause = () => {\n      setState({ isPlaying: false, isBuffering: false });\n    };\n\n    const getErrorInfo = (\n      errorCode: number\n    ): { message: string; recoverable: boolean } => {\n      switch (errorCode) {\n        case MediaError.MEDIA_ERR_ABORTED:\n          return { message: \"Playback cancelled\", recoverable: true };\n        case MediaError.MEDIA_ERR_NETWORK:\n          return { message: \"Network error\", recoverable: true };\n        case MediaError.MEDIA_ERR_DECODE:\n          return {\n            message: \"Audio file decoding error\",\n            recoverable: false,\n          };\n        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:\n          return {\n            message: \"File/network loading error (Code 4)\",\n            recoverable: true,\n          };\n        default:\n          return {\n            message: `Unknown error (${errorCode})`,\n            recoverable: true,\n          };\n      }\n    };\n\n    const parseError = (\n      e: Event\n    ): { message: string; recoverable: boolean; errorCode: number } => {\n      if (audio.error) {\n        const errorCode = audio.error.code;\n        const errorInfo = getErrorInfo(errorCode);\n        return { ...errorInfo, errorCode };\n      }\n\n      if (e instanceof ErrorEvent) {\n        return { message: e.message, recoverable: true, errorCode: 0 };\n      }\n\n      return {\n        message: \"Unknown audio error\",\n        recoverable: false,\n        errorCode: 0,\n      };\n    };\n\n    const handleErrorRetry = async (\n      audioElement: HTMLAudioElement,\n      recoverable: boolean\n    ): Promise<boolean> => {\n      if (!recoverable || errorRetryCountRef.current >= MAX_ERROR_RETRIES) {\n        return false;\n      }\n\n      return await retryPlayback(audioElement);\n    };\n\n    const handleError = async (e: Event) => {\n      const { message: initialMessage, recoverable, errorCode } = parseError(e);\n\n      console.error(\"Audio error details:\", {\n        event: e,\n        audioError: audio.error,\n        message: initialMessage,\n        recoverable,\n        code: errorCode,\n        src: audio.src,\n        readyState: audio.readyState,\n        networkState: audio.networkState,\n      });\n\n      if (await handleErrorRetry(audio, recoverable)) {\n        return;\n      }\n\n      const finalMessage =\n        recoverable && errorRetryCountRef.current >= MAX_ERROR_RETRIES\n          ? `Failed after ${MAX_ERROR_RETRIES} attempts: ${initialMessage}`\n          : initialMessage;\n\n      setState({\n        isPlaying: false,\n        isLoading: false,\n        isBuffering: false,\n        isError: true,\n        errorMessage: finalMessage,\n      });\n    };\n\n    const handleEnded = async () => {\n      setState({ isPlaying: false, isBuffering: false });\n\n      const state = useAudioStore.getState();\n\n      if (state.currentTrack && isLive(state.currentTrack)) {\n        console.warn(\"Live stream ended unexpectedly\");\n        setState({\n          isError: true,\n          errorMessage: \"Live stream connection lost\",\n        });\n        return;\n      }\n      if (state.repeatMode === \"one\" && state.currentTrack) {\n        try {\n          const isLiveStream = isLive(state.currentTrack);\n          await $audio.load(state.currentTrack.url, 0, isLiveStream);\n          await $audio.play();\n          setState({ currentTime: 0, progress: 0 });\n          return;\n        } catch (error) {\n          console.error(\"Repeat mode playback error:\", error);\n        }\n      }\n\n      state.handleTrackEnd();\n    };\n\n    const handleLoadStart = () => {\n      setState({\n        isLoading: true,\n        isBuffering: false,\n        isError: false,\n        errorMessage: null,\n      });\n    };\n\n    const handleCanPlay = () => {\n      const duration = audio.duration || 0;\n      setState({\n        isLoading: false,\n        isBuffering: false,\n        duration,\n        isError: false,\n        errorMessage: null,\n      });\n    };\n\n    const handleWaiting = () => {\n      setState({ isBuffering: true, isLoading: false });\n    };\n\n    const handlePlaying = () => {\n      setState({\n        isLoading: false,\n        isBuffering: false,\n        isPlaying: true,\n        isError: false,\n        errorMessage: null,\n      });\n    };\n\n    const handleDurationChange = () => {\n      const duration = audio.duration || 0;\n      setState({ duration });\n    };\n\n    const handleVolumeChange = () => {\n      setState({ volume: audio.volume, isMuted: audio.muted });\n    };\n\n    const handleBufferUpdate = (e: Event) => {\n      if (e instanceof CustomEvent && e.detail?.bufferedTime !== undefined) {\n        setState({ bufferedTime: e.detail.bufferedTime });\n      }\n    };\n\n    const restoreState = async () => {\n      const state = useAudioStore.getState();\n\n      if (!state.currentTrack || state.currentTime <= 0) {\n        return;\n      }\n\n      const track = state.currentTrack;\n      const isLiveStream = isLive(track);\n      const startTime = isLiveStream ? 0 : state.currentTime;\n      const volume = state.volume;\n      const muted = state.isMuted;\n\n      try {\n        setState({ isLoading: true });\n\n        await $audio.load(track.url, startTime, isLiveStream);\n        $audio.setVolume(volume);\n        $audio.setMuted(muted);\n\n        setState({ isLoading: false, isPlaying: false });\n      } catch (error) {\n        console.error(\"State restoration error:\", error);\n        setState({\n          isError: true,\n          errorMessage: \"Error restoring audio state\",\n          isPlaying: false,\n          isLoading: false,\n          isBuffering: false,\n        });\n      }\n    };\n\n    audio.addEventListener(\"play\", handlePlay);\n    audio.addEventListener(\"pause\", handlePause);\n    audio.addEventListener(\"playing\", handlePlaying);\n    audio.addEventListener(\"waiting\", handleWaiting);\n    audio.addEventListener(\"loadstart\", handleLoadStart);\n    audio.addEventListener(\"canplay\", handleCanPlay);\n    audio.addEventListener(\"canplaythrough\", handleCanPlay);\n    audio.addEventListener(\"timeupdate\", throttledTimeUpdate);\n    audio.addEventListener(\"durationchange\", handleDurationChange);\n    audio.addEventListener(\"loadedmetadata\", handleDurationChange);\n    audio.addEventListener(\"volumechange\", handleVolumeChange);\n    audio.addEventListener(\"ended\", handleEnded);\n    audio.addEventListener(\"error\", handleError);\n\n    $audio.addEventListener(\"bufferUpdate\", handleBufferUpdate);\n\n    restoreState();\n\n    const unsubscribe = useAudioStore.subscribe(\n      (state) => state.currentTrack?.id,\n      (newSongId, oldSongId) => {\n        if (newSongId && newSongId !== oldSongId) {\n          errorRetryCountRef.current = 0;\n          preloadNextTrack();\n        }\n      }\n    );\n\n    return () => {\n      audio.removeEventListener(\"play\", handlePlay);\n      audio.removeEventListener(\"pause\", handlePause);\n      audio.removeEventListener(\"playing\", handlePlaying);\n      audio.removeEventListener(\"waiting\", handleWaiting);\n      audio.removeEventListener(\"loadstart\", handleLoadStart);\n      audio.removeEventListener(\"canplay\", handleCanPlay);\n      audio.removeEventListener(\"canplaythrough\", handleCanPlay);\n      audio.removeEventListener(\"timeupdate\", throttledTimeUpdate);\n      audio.removeEventListener(\"durationchange\", handleDurationChange);\n      audio.removeEventListener(\"loadedmetadata\", handleDurationChange);\n      audio.removeEventListener(\"volumechange\", handleVolumeChange);\n      audio.removeEventListener(\"ended\", handleEnded);\n      audio.removeEventListener(\"error\", handleError);\n\n      $audio.removeEventListener(\"bufferUpdate\", handleBufferUpdate);\n\n      if (preloadAudioRef.current) {\n        preloadAudioRef.current.src = \"\";\n        preloadAudioRef.current = null;\n      }\n\n      unsubscribe();\n    };\n  }, [throttledTimeUpdate, setState, retryPlayback, preloadNextTrack]);\n\n  React.useEffect(() => {\n    const unsubscribe = useAudioStore.subscribe(\n      (state) => state.queue,\n      (newQueue, oldQueue) => {\n        if (\n          (newQueue.length !== oldQueue.length || newQueue.length === 0) &&\n          preloadAudioRef.current\n        ) {\n          preloadAudioRef.current.src = \"\";\n        }\n      }\n    );\n    return unsubscribe;\n  }, []);\n\n  return children;\n}\nconst demoTracks: Track[] = [\n  {\n    id: \"1\",\n    title: \"Beautiful Loop\",\n    artist: \"Flavio Concini\",\n    album: \"Pixabay Music\",\n    url: \"https://cdn.pixabay.com/audio/2024/10/21/audio_78251ef8e3.mp3\",\n    genre: \"Upbeat\",\n  },\n  {\n    id: \"2\",\n    title: \"Type\",\n    artist: \"Aliabbas Abasov\",\n    album: \"Pixabay Music\",\n    url: \"https://cdn.pixabay.com/audio/2024/02/28/audio_60f7a54400.mp3\",\n    genre: \"Hip Hop\",\n  },\n  {\n    id: \"3\",\n    title: \"Radio Tuxnet\",\n    artist: \"Tuxnet\",\n    url: \"/radio/live.aac?host=ice2.tuxnet.me\",\n    genre: \"Hip Hop\",\n    artwork: \"/icon\",\n  },\n  {\n    id: \"4\",\n    title: \"Live Radio\",\n    artist: \"Audio UI\",\n    url: \"https://radio.sevalla.app/live.aac\",\n    artwork: \"/icon\",\n    genre: \"Hip Hop\",\n  },\n];\nexport { AudioProvider, demoTracks };\n",
      "type": "registry:ui"
    }
  ]
}