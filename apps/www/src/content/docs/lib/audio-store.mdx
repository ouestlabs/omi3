---
title: Audio Store
description: Zustand-based store and helper actions for queue and playback management.
---

A Zustand store providing reactive state management for audio playback, queue control, and player UI. Persists essential state to localStorage automatically.

## Installation

### Dependencies

The store uses Zustand. Install it if your app doesn't already include it:

```bash
npm install zustand
```

### Import

Import the store hook and types:

```tsx
import {
  useAudioStore,
  calculateNextIndex,
  calculatePreviousIndex,
  canUseDOM,
  type AudioStore,
  type RepeatMode,
  type InsertMode,
} from "@/lib/audio-store"
```

## Core Concepts

### useAudioStore Hook

Access the store with granular selectors for better performance:

```tsx
// Recommended: selector-based subscriptions
const currentTime = useAudioStore((s) => s.currentTime)
const isPlaying = useAudioStore((s) => s.isPlaying)
```

For multiple values, extract them inside your component:

```tsx
function PlayerStatus() {
  const currentTrack = useAudioStore((s) => s.currentTrack)
  const duration = useAudioStore((s) => s.duration)
  const isPlaying = useAudioStore((s) => s.isPlaying)
  
  return (
    <p>
      {currentTrack?.title} ({duration}s) — {isPlaying ? "▶" : "⏸"}
    </p>
  )
}
```

## Types

### Track

Common audio track object. See [Audio library](/docs/lib/audio#track) for full definition.

```tsx
import type { Track } from "@/lib/audio"

type Track = {
  id?: string | number
  url: string
  title?: string
  artist?: string
  artwork?: string
  duration?: number
  live?: boolean
}
```

### AudioStore State

The store exposes state organized by concern:

**Playback**

- `isPlaying` — currently playing
- `isLoading` — loading track
- `isBuffering` — buffering audio
- `isError` — error state
- `errorMessage` — error details

**Current Track**

- `currentTrack` — active track object
- `currentTime` — playback position (seconds)
- `duration` — track length
- `progress` — normalized progress 0–1
- `bufferedTime` — buffered amount

**Queue**

- `queue` — array of tracks
- `history` — previously played tracks
- `currentQueueIndex` — active track index

**Controls**

- `volume` — volume 0–1
- `isMuted` — mute state
- `repeatMode` — none | one | all
- `shuffleEnabled` — shuffle state
- `insertMode` — insertion position for queue

### RepeatMode

```tsx
type RepeatMode = "none" | "one" | "all"
```

### InsertMode

Determines where new tracks are added to the queue:

```tsx
type InsertMode = "first" | "last" | "after"
```

## Utility Functions

### calculateNextIndex(queue, currentIndex, shuffleEnabled, repeatMode)

Calculate the next track index based on playback mode.

```tsx
const nextIndex = calculateNextIndex(
  queue,
  currentQueueIndex,
  shuffleEnabled,
  repeatMode
)
// Returns: number (track index or -1 if none)
```

### calculatePreviousIndex(queue, currentIndex, shuffleEnabled, repeatMode)

Calculate the previous track index based on playback mode.

```tsx
const prevIndex = calculatePreviousIndex(
  queue,
  currentQueueIndex,
  shuffleEnabled,
  repeatMode
)
// Returns: number (track index or -1 if none)
```

### canUseDOM()

Check if code runs in a DOM environment (not SSR).

```tsx
if (canUseDOM()) {
  // Browser-only code
}
```

## Actions

### Playback Control

```tsx
const play = useAudioStore((s) => s.play)
await play()

const pause = useAudioStore((s) => s.pause)
pause()

const togglePlay = useAudioStore((s) => s.togglePlay)
togglePlay()

const seek = useAudioStore((s) => s.seek)
seek(60) // Seek to 60 seconds
```

### Navigation

```tsx
const next = useAudioStore((s) => s.next)
await next() // Play next track

const previous = useAudioStore((s) => s.previous)
await previous() // Play previous track

const setCurrentTrack = useAudioStore((s) => s.setCurrentTrack)
await setCurrentTrack(track) // Load and play specific track
setCurrentTrack(null) // Clear current track

const setQueueAndPlay = useAudioStore((s) => s.setQueueAndPlay)
await setQueueAndPlay(tracks, startIndex)
```

### Queue Management

```tsx
const addToQueue = useAudioStore((s) => s.addToQueue)
addToQueue(track, "last") // Supports: "first" | "last" | "after"

const removeFromQueue = useAudioStore((s) => s.removeFromQueue)
removeFromQueue(trackId)

const moveInQueue = useAudioStore((s) => s.moveInQueue)
moveInQueue(fromIndex, toIndex)

const setQueue = useAudioStore((s) => s.setQueue)
setQueue(newTracks, startIndex)

const clearQueue = useAudioStore((s) => s.clearQueue)
clearQueue()
```

### Volume & Mute

```tsx
const setVolume = useAudioStore((s) => s.setVolume)
setVolume(0.5)

const toggleMute = useAudioStore((s) => s.toggleMute)
toggleMute()
```

### Playback Modes

```tsx
const changeRepeatMode = useAudioStore((s) => s.changeRepeatMode)
changeRepeatMode() // Cycles: none → one → all → none

const setRepeatMode = useAudioStore((s) => s.setRepeatMode)
setRepeatMode("one")

const shuffle = useAudioStore((s) => s.shuffle)
shuffle() // Randomize queue order

const unshuffle = useAudioStore((s) => s.unshuffle)
unshuffle() // Restore original order

const setInsertMode = useAudioStore((s) => s.setInsertMode)
setInsertMode("after")
```

### Error Handling

```tsx
const setError = useAudioStore((s) => s.setError)
setError("Failed to load track")
setError(null) // Clear error
```

## Examples

### Status Display

```tsx
import { useAudioStore } from "@/lib/audio-store"
import { formatDuration } from "@/lib/audio"

function PlayerStatus() {
  const currentTrack = useAudioStore((s) => s.currentTrack)
  const currentTime = useAudioStore((s) => s.currentTime)
  const duration = useAudioStore((s) => s.duration)
  const isPlaying = useAudioStore((s) => s.isPlaying)

  return (
    <div>
      <p>Track: {currentTrack?.title ?? "None"}</p>
      <p>Time: {formatDuration(currentTime)} / {formatDuration(duration)}</p>
      <p>Status: {isPlaying ? "▶" : "⏸"}</p>
    </div>
  )
}
```

### Custom Controls

```tsx
function CustomControls() {
  const togglePlay = useAudioStore((s) => s.togglePlay)
  const next = useAudioStore((s) => s.next)
  const previous = useAudioStore((s) => s.previous)
  const isPlaying = useAudioStore((s) => s.isPlaying)

  return (
    <div className="flex gap-2">
      <button onClick={previous}>◀ Prev</button>
      <button onClick={togglePlay}>{isPlaying ? "⏸" : "▶"}</button>
      <button onClick={next}>Next ▶</button>
    </div>
  )
}
```

### Queue Manager

```tsx
function QueueManager() {
  const queue = useAudioStore((s) => s.queue)
  const addToQueue = useAudioStore((s) => s.addToQueue)
  const removeFromQueue = useAudioStore((s) => s.removeFromQueue)
  const clearQueue = useAudioStore((s) => s.clearQueue)

  return (
    <div>
      <div className="flex gap-2 mb-4">
        <button onClick={() => addToQueue(newTrack, "last")}>Add Track</button>
        <button onClick={clearQueue} className="text-red-500">
          Clear
        </button>
      </div>
      <div className="space-y-1">
        {queue.map((track) => (
          <div key={track.id} className="flex justify-between">
            <span>{track.title}</span>
            <button onClick={() => removeFromQueue(track.id)}>Remove</button>
          </div>
        ))}
      </div>
    </div>
  )
}
```

### Direct Store Access

```tsx
import { useAudioStore } from "@/lib/audio-store"

// Read state without React subscriptions
const state = useAudioStore.getState()
console.log(state.isPlaying)

// Call actions directly
await useAudioStore.getState().play()

// Subscribe to changes (returns unsubscribe function)
const unsubscribe = useAudioStore.subscribe(
  (s) => s.isPlaying,
  (isPlaying) => console.log("Playing:", isPlaying)
)
```

## Persistence

The store automatically persists a subset of state to localStorage using Zustand's `persist` middleware:

**Persisted State**

- Playback: `currentTrack`, `currentTime`, `currentQueueIndex`
- Queue: `queue`, `history`
- Settings: `volume`, `isMuted`, `repeatMode`, `shuffleEnabled`, `insertMode`

**Storage Key**

```
audio:ui:store
```

This allows users to resume playback and maintain queue state across page refreshes.

## Related

- [Audio Library](/docs/lib/audio) — Core audio playback singleton
- [Audio Player](/docs/components/player) — Player UI components
- [Audio Queue](/docs/components/queue) — Queue management UI

## Notes

- Prefer selector subscriptions for performance (subscribe to specific slices of state)
- Async actions (`play`, `next`, `setCurrentTrack`) wait for audio loading
- `addToQueue` supports "first", "last", and "after" insert modes
- Queue shuffling randomizes order but preserves track identity
- `setQueueAndPlay` and similar actions trigger audio loading via the [Audio library](/docs/lib/audio)
- Persistence is automatic; no manual save required
- Direct store access via `getState()` is useful for non-React code or imperative operations
